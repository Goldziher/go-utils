{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Go Utils","text":"<p>Go Utils is a comprehensive Golang utilities library. The aim of this library is to offer high quality, performant and well tested utility functions using Go 1.18 Generics.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get -u github.com/Goldziher/go-utils\n</code></pre>"},{"location":"#why-this-library","title":"Why This Library?","text":"<ul> <li>\ud83d\udcaf Rigorously Tested</li> <li>\ud83d\ude80 Highly Performant</li> <li>\ud83d\udc4d Typed Using Generics</li> <li>\u2705 Production Ready</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>This project aims to be a community driven project. I'd like to encourage you to make suggestions, request features and contribute code.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>To contribute code changes or update the documentation, please follow these steps:</p> <ol> <li>Fork the upstream repository and clone the fork locally.</li> <li>Install pre-commit and install the hook by running <code>pre-commit install</code></li> <li>Make whatever changes and additions you wish and commit these - please try to keep your commit history clean.</li> <li>Create a pull request to the main repository with an explanation of your changes</li> </ol> <p>Note: if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.</p>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2022 Na'aman Hirschfeld</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"dateutils/afterorequal/","title":"AfterOrEqual","text":"<p><code>func AfterOrEqual(milestone time.Time, date time.Time) bool</code></p> <p>AfterOrEqual - returns true if a date is equal or after to another date</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    milestone, _ := time.Parse(\"2006-01-02\", \"2023-01-01\")\n\n    dBefore, _ := time.Parse(\"2006-01-02\", \"2022-12-31\")\n    dEqual, _ := time.Parse(\"2006-01-02\", \"2023-01-01\")\n    dAfter, _ := time.Parse(\"2006-01-02\", \"2023-01-31\")\n\n    dateutils.AfterOrEqual(milestone, dBefore) // false\n    dateutils.AfterOrEqual(milestone, dEqual) // true\n    dateutils.AfterOrEqual(milestone, dAfter) // true\n}\n</code></pre>"},{"location":"dateutils/beforeorequal/","title":"BeforeOrEqual","text":"<p><code>func BeforeOrEqual(milestone time.Time, date time.Time) bool</code></p> <p>BeforeOrEqual - returns true if a date is before or equal to another date</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    milestone, _ := time.Parse(\"2006-01-02\", \"2023-01-01\")\n\n    dBefore, _ := time.Parse(\"2006-01-02\", \"2022-12-31\")\n    dEqual, _ := time.Parse(\"2006-01-02\", \"2023-01-01\")\n    dAfter, _ := time.Parse(\"2006-01-02\", \"2023-01-31\")\n\n    dateutils.BeforeOrEqual(milestone, dBefore) // true\n    dateutils.BeforeOrEqual(milestone, dEqual) // true\n    dateutils.BeforeOrEqual(milestone, dAfter) // false\n}\n</code></pre>"},{"location":"dateutils/ceil/","title":"Ceil","text":"<p><code>func Ceil(t time.Time) time.Time</code></p> <p>Ceil - takes a datetime and return a datetime from the same day at 23:59:59.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    d, _ := time.Parse(\"2006-01-02\", \"2009-10-13\")\n    fmt.Println(dateutils.Ceil(d)) // 2009-10-13 23:59:59 +0000 UTC\n}\n</code></pre>"},{"location":"dateutils/floor/","title":"Floor","text":"<p><code>func Floor(t time.Time) time.Time</code></p> <p>Floor - takes a datetime and return a datetime from the same day at 00:00:00.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    d, _ := time.Parse(\"2006-01-02\", \"2009-10-13\")\n    fmt.Println(dateutils.Floor(d)) // 2009-10-13 00:00:00 +0000 UTC\n}\n</code></pre>"},{"location":"dateutils/overlap/","title":"Overlap","text":"<p><code>Overlap(start1 time.Time, end1 time.Time, start2 time.Time, end2 time.Time) bool</code></p> <p>Overlap - returns true if two date intervals overlap.</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    s1, _ := time.Parse(\"2006-01-02\", \"2022-12-28\")\n    e1, _ := time.Parse(\"2006-01-02\", \"2022-12-31\")\n\n    s2, _ := time.Parse(\"2006-01-02\", \"2022-12-30\")\n    e2, _ := time.Parse(\"2006-01-02\", \"2023-01-01\")\n\n    s3, _ := time.Parse(\"2006-01-02\", \"2023-01-02\")\n    e3, _ := time.Parse(\"2006-01-02\", \"2023-01-04\")\n\n    dateutils.Overlap(s1, e1, s2, e2) // true\n    dateutils.Overlap(s1, e1, s3, e3) // false\n}\n</code></pre>"},{"location":"maputils/copy/","title":"Copy","text":"<p><code>func Copy[K comparable, V any](mapInstance map[K]V) map[K]V</code></p> <p>Copy takes a map with keys K and values V and returns a copy.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    copiedVegetables := maputils.Copy(vegetables)\n\n    copiedVegetables[\"potatoes\"] = 3\n\n    fmt.Print(vegetables[\"potatoes\"])       // 5\n    fmt.Print(copiedVegetables[\"potatoes\"]) // 3\n}\n</code></pre>"},{"location":"maputils/filter/","title":"Filter","text":"<p><code>func Filter[K comparable, V any](mapInstance map[K]V, function func(key K, value V) bool) map[K]V</code></p> <p>Filter takes a map with keys K and values V, and executes the passed in function for each key-value pair. If the filter function returns true, the key-value pair will be included in the output, otherwise it is filtered out.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    result := maputils.Filter(vegetables, func(key string, value int) bool {\n        return value == 5\n    })\n\n    fmt.Print(result) // { \"potatoes\": 5 }\n}\n</code></pre>"},{"location":"maputils/forEach/","title":"ForEach","text":"<p><code>func ForEach[K comparable, V any](mapInstance map[K]V, function func(key K, value V))</code></p> <p>ForEach given a map with keys K and values V, executes the passed in function for each key-value pair.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    maputils.ForEach(vegetables, func(key string, value int) {\n        fmt.Printf(\"Buy %d Kg of %s\", value, key) //  \"Buy 5 Kg of potatoes\", \"Buy 10 Kg of carrots\"\n    })\n}\n</code></pre>"},{"location":"maputils/keys/","title":"Keys","text":"<p><code>func Keys[K comparable, V any](mapInstance map[K]V) []K</code></p> <p>Keys takes a map with keys K and values V and returns a slice of type K with the map's keys.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    result := maputils.Keys(vegetables)\n\n    fmt.Print(result) // [\"potatoes\", \"carrots\"]\n}\n</code></pre>"},{"location":"maputils/merge/","title":"Merge","text":"<p><code>func Merge[K comparable, V any](mapInstances ...map[K]V) map[K]V</code></p> <p>Merge takes a variadic numbers of maps with keys K and values V and returns a merged map. Merging is done from left to right. If a key already exists in a previous map, its value is over-written.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n        \"tomatoes\": 3,\n    }\n\n    fruits := map[string]int{\n        \"bananas\":  3,\n        \"tomatoes\": 5,\n    }\n\n    result := maputils.Merge(vegetables, fruits)\n\n    fmt.Print(result) //{ \"potatoes\": 5, \"carrots\":  10, \"tomatoes\": 5, \"bananas\": 3 }\n}\n</code></pre>"},{"location":"maputils/values/","title":"Values","text":"<p><code>func Values[K comparable, V any](mapInstance map[K]V) []V</code></p> <p>Values takes a map with keys K and values V and returns a slice of type V with the map's values.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    result := maputils.Values(vegetables)\n\n    fmt.Print(result) // [5, 10]\n}\n</code></pre>"},{"location":"sliceutils/chunk/","title":"Chunk","text":"<p><code>func Chunk[T any](input []T, size int) [][]T</code></p> <p>Unique takes a slice of type T and size N and returns a slice of slices T of size N.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    result1 := sliceutils.Chunk(numbers, 2) // [][]int{{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}}\n    result2 := sliceutils.Chunk(numbers, 3) // [][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10}}\n}\n</code></pre>"},{"location":"sliceutils/copy/","title":"Copy","text":"<p><code>func Copy[T any](slice []T) []T</code></p> <p>Copy receives a slice of type T and returns a copy.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1}\n\n    numeralsCopy := sliceutils.Copy(numerals)\n    numeralsCopy[0] = 1\n\n    fmt.Print(numerals)     // [0, 1]\n    fmt.Print(numeralsCopy) // [1, 1]\n}\n</code></pre>"},{"location":"sliceutils/difference/","title":"Difference","text":"<p><code>func Difference[T comparable](slices ...[]T) []T</code></p> <p>Difference takes a variadic number of slices of type T and returns a slice of type T containing the elements that are different between the slices.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    first, second := []int{1, 2, 3}, []int{1, 7, 3}\n\n    result := sliceutils.Difference(first, second)\n\n    fmt.Print(result) // [2, 7]\n}\n</code></pre>"},{"location":"sliceutils/ensureUniqueAndAppend/","title":"EnsureUniqueAndAppend","text":"<p><code>func EnsureUniqueAndAppend[T comparable](slice []T, item T) []T</code></p> <p>EnsureUniqueAndAppend appends an item to a slice if it does not already exists.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    slice := []string{}\n    item := \"go-utils\"\n\n    slice = sliceutils.EnsureUniqueAndAppend(slice, item) // [\"go-utils\"]\n    slice = sliceutils.EnsureUniqueAndAppend(slice, item) // [\"go-utils\"]\n}\n</code></pre>"},{"location":"sliceutils/every/","title":"Every","text":"<p><code>func Every[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool</code></p> <p>Every takes a slice of type T and a predicate function, returning true if the predicate returned true for every elements. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.Every(friends, func(value string, index int, slice []string) bool {\n        return value == \"Mandy\"\n    })\n\n    fmt.Print(result) // false\n}\n</code></pre>"},{"location":"sliceutils/filter/","title":"Filter","text":"<p><code>func Filter[T any](slice []T, predicate func(value T, index int, slice []T) bool) []T</code></p> <p>Filter takes a slice of type <code>T</code> and filters it using the given predicate function. The predicate is passed the current element, the current index and the slice as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    oddNumbers := sliceutils.Filter(numerals, func(value int, index int, slice []int) bool {\n        return value%2 != 0\n    })\n\n    fmt.Printf(\"%v\", oddNumbers) // [1 3 5 7 9]\n}\n</code></pre>"},{"location":"sliceutils/find/","title":"Find","text":"<p><code>func Find[T any](slice []T, predicate func(value T, index int, slice []T) bool) *T</code></p> <p>Find takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, a pointer to the element is returned. If no element is found, nil is returned. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    days := []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}\n\n    result := sliceutils.Find(days, func(value string, index int, slice []string) bool {\n        return strings.Contains(value, \"Wed\")\n    })\n\n    fmt.Print(result) // \"Wednesday\"\n}\n</code></pre>"},{"location":"sliceutils/findIndex/","title":"FindIndex","text":"<p><code>func FindIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int</code></p> <p>FindIndex takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, the element's index is returned. If no element is found, <code>-1</code> is returned. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    days := []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}\n\n    result := sliceutils.FindIndex(days, func(value string, index int, slice []string) bool {\n        return strings.Contains(value, \"Wed\")\n    })\n\n    fmt.Print(result) // 3\n}\n</code></pre>"},{"location":"sliceutils/findIndexOf/","title":"FindIndexOf","text":"<p><code>func FindIndexOf[T comparable](slice []T, value T) int</code></p> <p>FindIndexOf takes a slice of type T and a value of type T. If any element in the slice equals the given value, its index is returned. If no element is found, <code>-1</code> is returned.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    days := []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}\n\n    result := sliceutils.FindIndexOf(days, \"Wednesday\")\n\n    fmt.Print(result) // 3\n}\n</code></pre>"},{"location":"sliceutils/findIndexes/","title":"FindIndexes","text":"<p><code>func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int</code></p> <p>FindIndexes takes a slice of type T and executes the passed in predicate function for each element in the slice, returning a slice containing all indexes for which the predicate returned true. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindIndexes(friends, func(value string, index int, slice []string) bool {\n        return value == \"John\"\n    })\n\n    fmt.Print(result) // [0, 4]\n}\n</code></pre>"},{"location":"sliceutils/findIndexesOf/","title":"FindIndexesOf","text":"<p><code>func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int</code></p> <p>FindIndexesOf takes a slice of type T and a value of type T, returning a slice containing all indexes where elements equal the passed in value.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindIndexesOf(friends, \"John\")\n\n    fmt.Print(result) // [0, 4]\n}\n</code></pre>"},{"location":"sliceutils/findLastIndex/","title":"FindLastIndex","text":"<p><code>func FindLastIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int</code></p> <p>FindLastIndex takes a slice of type T and executes the passed in predicate function for each element in the slice starting from its end. If the predicate returns true, the element's index is returned. If no element is found, <code>-1</code> is returned. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindLastIndex(friends, func(value string, index int, slice []string) bool {\n        return value == \"John\"\n    })\n\n    fmt.Print(result) // 4\n}\n</code></pre>"},{"location":"sliceutils/findLastIndexOf/","title":"FindLastIndexOf","text":"<p><code>func FindLastIndexOf[T comparable](slice []T, value T) int</code></p> <p>FindLastIndexOf takes a slice of type T and a value of type T. If any element in the slice equals the given value, the last index of is occurrence is returned. If no element is found, <code>-1</code> is returned.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindLastIndexOf(friends, \"John\")\n\n    fmt.Print(result) // 4\n}\n</code></pre>"},{"location":"sliceutils/flatMap/","title":"FlatMap","text":"<p><code>func FlatMap[T any, R any](slice []T, mapper func(value T, index int, slice []T) []R) []R</code></p> <p>FlatMap receives a slice of type T, executes the passed in slice-mapper function for each element in the slice, and returns a flattened slice containing all the elements from all the mapped slices. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    items := []int{1, 2, 3, 4}\n\n    flatMapped := sliceutils.FlatMap(items, func(value int, index int, slice []int) []int {\n        return []int{value, value * 2}\n    }) // []int{1, 2, 2, 4, 3, 6, 4, 8}\n}\n</code></pre>"},{"location":"sliceutils/flatten/","title":"Flatten","text":"<p><code>Flatten[I any](input [][]I) []I</code></p> <p>Flatten - receives a slice of slice of type I and flattens it to a slice of type I.</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    items := [][]int{\n        {1, 2, 3, 4},\n        {5, 6},\n        {7, 8},\n        {9, 10, 11},\n    }\n\n    flattened := sliceutils.Flatten(items) //[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}\n}\n</code></pre>"},{"location":"sliceutils/forEach/","title":"ForEach","text":"<p><code>func ForEach[T any](slice []T, function func(value T, index int, slice []T))</code></p> <p>ForEach executes the passed in function for each element in the given slice. The function is passed the current element, the current index and the slice as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    result := 0\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    sliceutils.ForEach(numerals, func(value int, index int, slice []int) {\n        result += value\n    })\n\n    fmt.Print(result) // 45\n}\n</code></pre>"},{"location":"sliceutils/includes/","title":"Includes","text":"<p><code>func Includes[T comparable](slice []T, value T) bool</code></p> <p>Includes receives a slice of type T and a value of type T, determining whether or not the value is included in the slice.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.Includes(friends, \"John\")\n\n    fmt.Print(result) // true\n}\n</code></pre>"},{"location":"sliceutils/insert/","title":"Insert","text":"<p><code>func Insert[T any](slice []T, i int, value T) []T</code></p> <p>Insert takes a slice of type T, an index and a value of type T, inserting the value at the given index and shifting any existing elements to the right.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 2}\n\n    numerals = sliceutils.Insert(numerals, 1, 1)\n\n    fmt.Print(numerals) // [0, 1, 2]\n}\n</code></pre>"},{"location":"sliceutils/intersection/","title":"Intersection","text":"<p><code>func Intersection[T comparable](slices ...[]T) []T</code></p> <p>Intersection takes a variadic number of slices of type T and returns a slice of type T containing any values that are common to all slices.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    first, second := []int{1, 2, 3}, []int{1, 7, 3}\n\n    result := sliceutils.Intersection(first, second)\n\n    fmt.Print(result) // [1, 3]\n}\n</code></pre>"},{"location":"sliceutils/map/","title":"Map","text":"<p><code>func Map[T any, R any](slice []T, mapper func(value T, index int, slice []T) R) (mapped []R)</code></p> <p>Map allows transforming the values in a slice by executing the given mapper function for each element in the slice. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    result := sliceutils.Map(numerals, func(value int, index int, slice []int) int {\n        return value * 2\n    })\n\n    fmt.Print(result) // [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n}\n</code></pre>"},{"location":"sliceutils/merge/","title":"Merge","text":"<p><code>func Merge[T any](slices ...[]T) (mergedSlice []T)</code></p> <p>Merge takes slices of type T and merges them into a single slice of type T, preserving their order.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    first := []int{1, 2, 3}\n    second := []int{4, 5, 6}\n    third := []int{7, 8, 9}\n\n    result := sliceutils.Merge(first, second, third)\n\n    fmt.Print(result) // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n}\n</code></pre>"},{"location":"sliceutils/pluck/","title":"Pluck","text":"<p><code>func Pluck[I any, O any](input []I, getter func(I) *O) []O</code></p> <p>Pluck receives a slice of type I and a getter func to a field and returns an array containing requested field from each slice's item.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    items := []Pluckable{\n        {\n            Code:  \"azer\",\n            Value: \"Azer\",\n        },\n        {\n            Code:  \"tyuio\",\n            Value: \"Tyuio\",\n        },\n    }\n\n    result1 := sliceutils.Pluck(items, func(item Pluckable) *string {\n        return &amp;item.Code\n    }) // []string{\"azer\", \"tyuio\"\"}\n    result2 := sliceutils.Pluck(items, func(item Pluckable) *string {\n        return &amp;item.Value\n    }) // []string{\"Azer\", \"Tyuio\"}\n}\n</code></pre>"},{"location":"sliceutils/reduce/","title":"Reduce","text":"<p><code>func Reduce[T any, R any](slice []T, reducer func(acc R, value T, index int, slice []T) R, initial R) R</code></p> <p>Reduce allows transforming the slice and its values into a different value by executing the given reducer function for each element in the slice. The function is passed the accumulator, current element, current index and the slice as function arguments. The third argument to reduce is the initial value.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    sum := sliceutils.Reduce(\n        numerals,\n        func(acc int, cur int, index int, slice []int) int {\n            return acc + cur\n        },\n        0,\n    )\n\n    fmt.Print(sum) // 45\n}\n</code></pre>"},{"location":"sliceutils/remove/","title":"Remove","text":"<p><code>func Remove[T any](slice []T, i int) []T</code></p> <p>Remove takes a slice of type T and an index, removing the element at the given index.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    numerals = sliceutils.Remove(numerals, 3)\n\n    fmt.Print(numerals) // [0, 1, 2, 4, 5, 6, 7, 8, 9]\n}\n</code></pre>"},{"location":"sliceutils/reverse/","title":"Reverse","text":"<p><code>func Reverse[T any](slice []T) []T</code></p> <p>Reverse takes a slice of type T and returns a slice of type T with a reverse order of elements.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    reversed := sliceutils.Reverse(numerals)\n\n    fmt.Print(reversed) // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n}\n</code></pre>"},{"location":"sliceutils/some/","title":"Some","text":"<p><code>func Some[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool</code></p> <p>Some takes a slice of type T and a predicate function, returning true if the predicate returned true for some elements. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.Some(friends, func(value string, index int, slice []string) bool {\n        return value == \"Mandy\"\n    })\n\n    fmt.Print(result) // true\n}\n</code></pre>"},{"location":"sliceutils/sum/","title":"Sum","text":"<p><code>func Sum[T numbers](slice []T) (result T)</code></p> <p>Sum takes a slice of numbers T, which can be any of the number types, and returns a sum of their values.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    result := sliceutils.Sum(numerals)\n\n    fmt.Print(result) // 45\n}\n</code></pre>"},{"location":"sliceutils/union/","title":"Union","text":"<p><code>func Union[T comparable](slices ...[]T) []T</code></p> <p>Union takes a variadic number of slices of type T and returns a slice of type T containing the unique elements in the different slices.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    first, second := []int{1, 2, 3}, []int{1, 7, 3}\n\n    result := sliceutils.Union(first, second)\n\n    fmt.Print(result) // [1, 2, 3, 7]\n}\n</code></pre>"},{"location":"sliceutils/unique/","title":"Unique","text":"<p><code>func Unique[T comparable](slice []T) []T</code></p> <p>Unique takes a slice of type T and returns a slice of type T containing all unique elements.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 3, 1}\n\n    result := sliceutils.Unique(numerals)\n\n    fmt.Print(result) // [0, 1, 2, 3]\n}\n</code></pre>"},{"location":"stringutils/capitalize/","title":"PadLeft","text":"<p><code>func Capitalize(str string) string</code></p> <p>Capitalize - Capitalizes a string by changing the casing format of the first letter of the string.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    result := stringutils.Capitalize(\"coffee\") // \"Coffee\"\n    fmt.Print(result) // \"Coffee\"\n}\n</code></pre>"},{"location":"stringutils/padLeft/","title":"PadLeft","text":"<p><code>func PadLeft(str string, padWith string, padTo int) string</code></p> <p>PadLeft - Pad a string to a certain length with another string on the left side. If padding string is more than one char, it might be trucated to fit padTo size.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    result := stringutils.PadLeft(\"Azer\", \"_\", 7) // \"___Azer\"\n    fmt.Print(result) // \"___Azer\"\n\n    result = stringutils.PadLeft(\"Azer\", \"_-\", 7) // \"_-_Azer\"\n    fmt.Print(result) // \"_-_Azer\"\n}\n</code></pre>"},{"location":"stringutils/padRight/","title":"PadRight","text":"<p><code>func PadRight(str string, padWith string, padTo int) string</code></p> <p>PadRight - Pad a string to a certain length with another string on the right side. If padding string is more than one char, it might be trucated to fit padTo size.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    result := stringutils.PadRight(\"Azer\", \"_\", 7) // \"Azer___\"\n    fmt.Print(result) // \"Azer___\"\n\n\n    result = stringutils.PadRight(\"Azer\", \"_-\", 7) // \"Azer_-_\"\n    fmt.Print(result) // \"Azer_-_\"\n}\n</code></pre>"},{"location":"stringutils/stringify/","title":"Stringify","text":"<p><code>func Stringify(value any, opts ...Options) string</code></p> <p>Stringify receives an arbitrary value and converts it into a string.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    value := 1000\n\n    result := stringutils.Stringify(value) // \"1000\"\n\n    fmt.Print(result) // \"1000\"\n}\n</code></pre> <p>Stringify also accepts an options object with the following properties:</p> <ul> <li><code>NilFormat</code>: the string format for nil values, defaults to \"\". <li><code>NilMapFormat</code>: the string format for nil map objects, defaults to \"{}\".</li> <li><code>NilSliceFormat</code>: the string format for nil slice objects, defaults to \"[]\".</li> <li><code>Base</code>: a number between 2-36 ad the base when converting ints and uints to strings, defaults to Base 10.</li> <li><code>Precision</code>: number of digits to include when converting floats and complex numbers to strings, defaults to 2.</li> <li><code>Format</code>: the number notation format, using the stlib <code>FTOA</code> functionalities, defaults to 'f':</li> <li>'b' (-ddddp\u00b1ddd, a binary exponent),</li> <li>'e' (-d.dddde\u00b1dd, a decimal exponent),</li> <li>'E' (-d.ddddE\u00b1dd, a decimal exponent),</li> <li>'f' (-ddd.dddd, no exponent),</li> <li>'g' ('e' for large exponents, 'f' otherwise),</li> <li>'G' ('E' for large exponents, 'f' otherwise),</li> <li>'x' (-0xd.ddddp\u00b1ddd, a hexadecimal fraction and binary exponent), or</li> <li>'X' (-0Xd.ddddP\u00b1ddd, a hexadecimal fraction and binary exponent).</li>"},{"location":"structutils/forEach/","title":"ForEach","text":"<p><code>func ForEach[T any](structInstance T, function func(key string, value any, tag reflect.StructTag))</code></p> <p>Takes a struct and calls the passed in function for each of its visible fields, passing to in the field's name, value and tag.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"myValue\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    structutils.ForEach(personInstance, func(key string, value any, tag reflect.StructTag) {\n        fmt.Printf(\"%v - %v - %v\\n\", key, value, tag.Get(\"myTag\"))\n    })\n\n    // FirstName - Moishe\n    // LastName - Zuchmir\n    // Age - 100 - myValue\n}\n</code></pre>"},{"location":"structutils/toMap/","title":"ToMap","text":"<p><code>func ToMap[T any](structInstance T, structTags ...string) map[string]any</code></p> <p>ToMap takes a struct and converts it to into an instance of <code>map[string]any</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"myValue\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    personMap := structutils.ToMap(personInstance)\n\n    fmt.Print(personMap)\n    // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"Age\": 100 }\n}\n</code></pre> <p>You can also pass in struct tags as an optional argument:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"myValue\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    personMap := structutils.ToMap(personInstance, \"myTag\")\n\n    fmt.Print(personMap)\n    // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"myTag\": 100 }\n}\n</code></pre> <p>To omit a value, use the standard <code>\"-\"</code> struct tag value:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"-\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    personMap := structutils.ToMap(personInstance, \"myTag\")\n\n    fmt.Print(personMap)\n    // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\" }\n}\n</code></pre>"},{"location":"urlutils/queryStringifyMap/","title":"QueryStringifyMap","text":"<p><code>func QueryStringifyMap[K comparable, V any](values map[K]V) string</code></p> <p>Creates a query string from a given map instance.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := map[string]any{\n        \"user\":    \"moishe\",\n        \"active\":  true,\n        \"age\":     100,\n        \"friends\": []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyMap(values)\n\n    fmt.Print(result) // \"active=true&amp;age=100&amp;friends=1&amp;friends=2&amp;friends=3&amp;friends=4&amp;friends=5&amp;friends=6&amp;user=moishe\"\n}\n</code></pre>"},{"location":"urlutils/queryStringifyStruct/","title":"QueryStringifyStruct","text":"<p><code>func QueryStringifyStruct[T any](values T, structTags ...string) string</code></p> <p>Creates a query string from a given struct instance. Takes struct tag names as optional parameters.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := struct {\n        User    string\n        Active  bool\n        Age     int `qs:\"age\"`\n        Friends []int\n    }{\n        User:    \"moishe\",\n        Active:  true,\n        Age:     100,\n        Friends: []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyStruct(values, \"qs\")\n\n    fmt.Print(result) // \"Active=true&amp;Friends=1&amp;Friends=2&amp;Friends=3&amp;Friends=4&amp;Friends=5&amp;Friends=6&amp;User=moishe&amp;age=100\"\n}\n</code></pre> <p>You can pass as many struct tags as you deem necessary, for example the following will also work:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := struct {\n        User    string\n        Active  bool `json:\"active\"`\n        Age     int `qs:\"age\"`\n        Friends []int\n    }{\n        User:    \"moishe\",\n        Active:  true,\n        Age:     100,\n        Friends: []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyStruct(values, \"json\", \"qs\")\n\n    fmt.Print(result) // \"Friends=1&amp;Friends=2&amp;Friends=3&amp;Friends=4&amp;Friends=5&amp;Friends=6&amp;User=moishe&amp;active=true&amp;age=100\"\n}\n</code></pre> <p>If you want to ignore a field, simply use the conventional tag value of <code>\"-\"</code>:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := struct {\n        User    string\n        Active  bool\n        Age     int `qs:\"-\"`\n        Friends []int\n    }{\n        User:    \"moishe\",\n        Active:  true,\n        Age:     100,\n        Friends: []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyStruct(values, \"qs\")\n\n    fmt.Print(result) // \"Active=true&amp;Friends=1&amp;Friends=2&amp;Friends=3&amp;Friends=4&amp;Friends=5&amp;Friends=6&amp;User=moishe\"\n}\n</code></pre>"}]}