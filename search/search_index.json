{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Go Utils","text":"<p>Functional programming utilities for Go 1.21+ designed to complement the standard library's <code>slices</code>, <code>maps</code>, and <code>cmp</code> packages.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get -u github.com/Goldziher/go-utils\n</code></pre>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Complementary to stdlib: Use <code>slices.Index</code>, <code>slices.Contains</code>, <code>slices.Clone</code> for basic operations. Use this library for functional patterns (Map, Filter, Reduce), LINQ-style operations (GroupBy, Partition), and utilities not available in stdlib.</p> <p>Type-safe generics: All functions leverage Go 1.21+ generics with appropriate constraints (<code>comparable</code>, <code>cmp.Ordered</code>, etc.) for compile-time type safety.</p> <p>Immutable by default: Functions don't mutate inputs unless explicitly named (e.g., <code>Remove</code> creates new slices).</p> <p>100% test coverage: Every function has comprehensive test coverage maintained by CI.</p>"},{"location":"#packages","title":"Packages","text":""},{"location":"#sliceutils","title":"sliceutils","text":"<p>Functional operations and LINQ-style utilities for slices.</p> <pre><code>import \"github.com/Goldziher/go-utils/sliceutils\"\n\n// Functional patterns\nnumbers := []int{1, 2, 3, 4, 5}\ndoubled := sliceutils.Map(numbers, func(v, i int, s []int) int { return v * 2 })\nevens := sliceutils.Filter(numbers, func(v, i int, s []int) bool { return v%2 == 0 })\nsum := sliceutils.Reduce(numbers, func(acc, v, i int, s []int) int { return acc + v }, 0)\n\n// LINQ-style operations\ntype User struct { Name string; Age int }\nusers := []User{{\"Alice\", 30}, {\"Bob\", 25}, {\"Charlie\", 30}}\nbyAge := sliceutils.GroupBy(users, func(u User) int { return u.Age })\nadults, minors := sliceutils.Partition(users, func(u User) bool { return u.Age &gt;= 18 })\n</code></pre>"},{"location":"#maputils","title":"maputils","text":"<p>Map transformations and utilities.</p> <pre><code>import \"github.com/Goldziher/go-utils/maputils\"\n\nm := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}\nkeys := maputils.Keys(m)           // []string{\"a\", \"b\", \"c\"}\nvalues := maputils.Values(m)       // []int{1, 2, 3}\nfiltered := maputils.Filter(m, func(k string, v int) bool { return v &gt; 1 })\n</code></pre>"},{"location":"#stringutils","title":"stringutils","text":"<p>String manipulation with type-safe conversion.</p> <pre><code>import \"github.com/Goldziher/go-utils/stringutils\"\n\n// Type-safe stringify with options\nstr := stringutils.Stringify(42, stringutils.Options{Base: 16})  // \"2a\"\n\n// String manipulation\npadded := stringutils.PadLeft(\"42\", \"0\", 5)  // \"00042\"\ncapitalized := stringutils.Capitalize(\"hello\")  // \"Hello\"\n</code></pre>"},{"location":"#structutils","title":"structutils","text":"<p>Reflection-based struct utilities with tag support.</p> <pre><code>import \"github.com/Goldziher/go-utils/structutils\"\n\ntype Config struct {\n    Host string `json:\"host\"`\n    Port int    `json:\"port\"`\n}\n\ncfg := Config{Host: \"localhost\", Port: 8080}\nm := structutils.ToMap(cfg, \"json\")  // map[string]any{\"host\": \"localhost\", \"port\": 8080}\n</code></pre>"},{"location":"#dateutils","title":"dateutils","text":"<p>Time and date utilities for business logic.</p> <pre><code>import \"github.com/Goldziher/go-utils/dateutils\"\n\n// Business day calculations\nfuture := dateutils.AddBusinessDays(time.Now(), 5)\n\n// Date overlap detection\noverlaps := dateutils.Overlap(start1, end1, start2, end2)\n\n// Age calculation\nage := dateutils.Age(birthdate)\n</code></pre>"},{"location":"#urlutils","title":"urlutils","text":"<p>URL parsing and query string builders.</p> <pre><code>import \"github.com/Goldziher/go-utils/urlutils\"\n\n// Query string from map\nparams := map[string]any{\"page\": 1, \"tags\": []string{\"go\", \"utils\"}}\nquery := urlutils.QueryStringifyMap(params)  // \"page=1&amp;tags=go&amp;tags=utils\"\n\n// Query string from struct with tags\ntype Query struct {\n    Page int      `qs:\"page\"`\n    Tags []string `qs:\"tag\"`\n}\nq := Query{Page: 1, Tags: []string{\"go\", \"utils\"}}\nquery := urlutils.QueryStringifyStruct(q, \"qs\")\n</code></pre>"},{"location":"#mathutils","title":"mathutils","text":"<p>Generic math operations with type constraints.</p> <pre><code>import \"github.com/Goldziher/go-utils/mathutils\"\n\nclamped := mathutils.Clamp(value, min, max)\ninRange := mathutils.InRange(value, min, max)\nisPrime := mathutils.IsPrime(17)  // true\ngcd := mathutils.Gcd(48, 18)      // 6\n</code></pre>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>Go Package Documentation</li> <li>Issue Tracker</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>To contribute code changes or update the documentation, please follow these steps:</p> <ol> <li>Fork the upstream repository and clone the fork locally.</li> <li>Install prek (a Rust rewrite of pre-commit):</li> </ol> <pre><code># Using uv (recommended)\nuv tool install prek\n\n# Or using pip\npip install prek\n</code></pre> <ol> <li>Navigate to the cloned repository's directory and install the hooks by running:</li> </ol> <pre><code>prek install &amp;&amp; prek install --hook-type commit-msg\n</code></pre> <ol> <li>Make whatever changes and additions you wish and commit these - please try to keep your commit history clean.</li> <li>Create a pull request to the main repository with an explanation of your changes.</li> </ol> <p>Note:</p> <ul> <li>if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.</li> <li>we follow conventional commits and this is enforced using commitlint via a pre-commit hook.</li> </ul>"},{"location":"dateutils/","title":"dateutils","text":"<p>Time and date utilities for business logic and date manipulation.</p>"},{"location":"dateutils/#overview","title":"Overview","text":"<p>The <code>dateutils</code> package provides utilities for working with dates and times, including business day calculations, date range operations, and common date manipulations.</p>"},{"location":"dateutils/#functions","title":"Functions","text":"<p>Date Boundaries: Floor, Ceil, StartOfDay, EndOfDay, StartOfWeek, EndOfWeek Month Operations: GetFirstDayOfMonth, GetLastDayOfMonth, DaysInMonth Date Ranges: Overlap, DaysBetween Business Logic: AddBusinessDays, IsWeekend, IsWeekday Age Calculation: Age, AgeAt Parsing: ParseDate, ParseDateWithLayout, MustParseDate, MustParseDateWithLayout Comparison: IsSameDay, IsSameMonth</p>"},{"location":"dateutils/#example","title":"Example","text":"<pre><code>import (\n    \"time\"\n    \"github.com/Goldziher/go-utils/dateutils\"\n)\n\nnow := time.Now()\n\n// Date boundaries\nstartOfDay := dateutils.StartOfDay(now)      // Today at 00:00:00\nendOfDay := dateutils.EndOfDay(now)          // Today at 23:59:59.999999999\nstartOfWeek := dateutils.StartOfWeek(now)    // This Sunday at 00:00:00\n\n// Business day calculations\nnextWeek := dateutils.AddBusinessDays(now, 5)  // 5 business days from now\nisWeekend := dateutils.IsWeekend(now)          // true if Saturday/Sunday\n\n// Date range operations\nstart1 := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)\nend1 := time.Date(2024, 1, 10, 0, 0, 0, 0, time.UTC)\nstart2 := time.Date(2024, 1, 5, 0, 0, 0, 0, time.UTC)\nend2 := time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC)\n\noverlaps := dateutils.Overlap(start1, end1, start2, end2)  // true\n\n// Age calculation\nbirthdate := time.Date(1990, 5, 15, 0, 0, 0, 0, time.UTC)\nage := dateutils.Age(birthdate)  // Current age in years\n\n// Month operations\nfirstDay := dateutils.GetFirstDayOfMonth()     // First day of current month\nlastDay := dateutils.GetLastDayOfMonth()       // Last day of current month\ndaysInMonth := dateutils.DaysInMonth(now)      // Number of days in current month\n\n// Date comparison\nsame := dateutils.IsSameDay(time.Now(), time.Now().Add(time.Hour))  // true\nsameMonth := dateutils.IsSameMonth(start1, start2)  // true\n</code></pre>"},{"location":"dateutils/ceil/","title":"Ceil","text":"<p><code>func Ceil(t time.Time) time.Time</code></p> <p>Ceil - takes a datetime and return a datetime from the same day at 23:59:59.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    d, _ := time.Parse(\"2006-01-02\", \"2009-10-13\")\n    fmt.Println(dateutils.Ceil(d)) // 2009-10-13 23:59:59 +0000 UTC\n}\n</code></pre>"},{"location":"dateutils/floor/","title":"Floor","text":"<p><code>func Floor(t time.Time) time.Time</code></p> <p>Floor - takes a datetime and return a datetime from the same day at 00:00:00.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    d, _ := time.Parse(\"2006-01-02\", \"2009-10-13\")\n    fmt.Println(dateutils.Floor(d)) // 2009-10-13 00:00:00 +0000 UTC\n}\n</code></pre>"},{"location":"dateutils/overlap/","title":"Overlap","text":"<p><code>Overlap(start1 time.Time, end1 time.Time, start2 time.Time, end2 time.Time) bool</code></p> <p>Overlap - returns true if two date intervals overlap.</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/dateutils\"\n    \"time\"\n)\n\nfunc main() {\n    s1, _ := time.Parse(\"2006-01-02\", \"2022-12-28\")\n    e1, _ := time.Parse(\"2006-01-02\", \"2022-12-31\")\n\n    s2, _ := time.Parse(\"2006-01-02\", \"2022-12-30\")\n    e2, _ := time.Parse(\"2006-01-02\", \"2023-01-01\")\n\n    s3, _ := time.Parse(\"2006-01-02\", \"2023-01-02\")\n    e3, _ := time.Parse(\"2006-01-02\", \"2023-01-04\")\n\n    dateutils.Overlap(s1, e1, s2, e2) // true\n    dateutils.Overlap(s1, e1, s3, e3) // false\n}\n</code></pre>"},{"location":"excutils/","title":"excutils","text":"<p>Exception-style error handling utilities for Go.</p>"},{"location":"excutils/#overview","title":"Overview","text":"<p>The <code>excutils</code> package (imported as <code>exc</code>) provides utilities for common error handling patterns including panic-on-error, error recovery, and safe error checking. While Go favors explicit error returns, these utilities can make certain patterns more concise.</p>"},{"location":"excutils/#functions","title":"Functions","text":"<p>Panic on Error: Must, MustResult, MustNotNil, ReturnNotNil Recovery: Try, Catch, RecoverWithValue Error Utilities: FirstErr, AllErr, ReturnAnyErr, IgnoreErr Retry: Retry, RetryWithResult</p>"},{"location":"excutils/#example","title":"Example","text":"<pre><code>import exc \"github.com/Goldziher/go-utils/excutils\"\n\n// Panic on error (for setup/initialization)\nfile := exc.MustResult(os.Open(\"config.json\"), \"failed to open config\")\n\n// Safe recovery\nerr := exc.Try(func() error {\n    // Code that might panic or error\n    return riskyOperation()\n})\n\n// Get first error\nerr := exc.FirstErr(err1, err2, err3)\n\n// Retry with exponential backoff\nerr = exc.Retry(func() error {\n    return httpClient.Do(req)\n}, 3)\n</code></pre>"},{"location":"excutils/allErr/","title":"AllErr","text":"<p><code>func AllErr(errs ...error) error</code></p> <p>AllErr returns an error containing all non-nil errors from the list. Returns nil if all errors are nil. Multiple errors are joined using errors.Join (Go 1.20+).</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    err1 := errors.New(\"first error\")\n    err2 := errors.New(\"second error\")\n\n    // Join all non-nil errors\n    err := exc.AllErr(nil, err1, nil, err2)\n    fmt.Println(err)\n    // first error\n    // second error\n}\n</code></pre>"},{"location":"excutils/catch/","title":"Catch","text":"<p><code>func Catch(fn func() error) (err error)</code></p> <p>Catch executes a function and recovers from any panics, converting them to errors. Returns the function's error if any, or an error created from a recovered panic.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    err := exc.Catch(func() error {\n        // This might panic\n        panic(\"something went wrong\")\n    })\n\n    fmt.Printf(\"Caught: %v\\n\", err)\n    // Caught: panic: something went wrong\n}\n</code></pre>"},{"location":"excutils/firstErr/","title":"FirstErr","text":"<p><code>func FirstErr(errs ...error) error</code></p> <p>FirstErr returns the first non-nil error from a list of errors. Returns nil if all errors are nil.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    err1 := errors.New(\"first error\")\n    err2 := errors.New(\"second error\")\n\n    // Get first non-nil error\n    err := exc.FirstErr(nil, nil, err1, err2)\n    fmt.Println(err)  // first error\n\n    // All nil\n    err = exc.FirstErr(nil, nil, nil)\n    fmt.Println(err)  // &lt;nil&gt;\n}\n</code></pre>"},{"location":"excutils/ignoreErr/","title":"IgnoreErr","text":"<p><code>func IgnoreErr(fn func() error)</code></p> <p>IgnoreErr executes a function that returns an error and ignores the error. This is useful for cleanup operations where errors can be safely ignored.</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    file, _ := os.Open(\"temp.txt\")\n    defer exc.IgnoreErr(file.Close)\n\n    // Use file...\n    // Close error will be ignored\n}\n</code></pre>"},{"location":"excutils/must/","title":"Must","text":"<p><code>func Must(err error, messages ...string)</code></p> <p>Must panics if the error is not nil. This is useful for initialization or setup code where errors should never occur. The optional messages are formatted and included in the panic message.</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    // Panic if error occurs\n    err := os.Chdir(\"/tmp\")\n    exc.Must(err, \"failed to change directory\")\n\n    // Continue if no error\n    println(\"Successfully changed directory\")\n}\n</code></pre>"},{"location":"excutils/mustNotNil/","title":"MustNotNil","text":"<p><code>func MustNotNil[T any](value *T, messages ...string) T</code></p> <p>MustNotNil panics with a formatted error message if the value is nil. Returns the dereferenced value if not nil.</p> <pre><code>package main\n\nimport (\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    numPtr := ptr.To(42)\n\n    // Returns dereferenced value if not nil\n    value := exc.MustNotNil(numPtr, \"number must not be nil\")\n    println(value)  // 42\n\n    // Panics if nil\n    var nilPtr *int\n    exc.MustNotNil(nilPtr, \"unexpected nil value\")  // panics\n}\n</code></pre>"},{"location":"excutils/mustResult/","title":"MustResult","text":"<p><code>func MustResult[T any](value T, err error, messages ...string) T</code></p> <p>MustResult panics if the error is not nil, otherwise returns the result. This is useful for cases where an error should never occur and you want to fail fast. The optional messages are formatted and included in the panic message.</p> <pre><code>package main\n\nimport (\n    \"os\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    // Panic if error, otherwise return file\n    file := exc.MustResult(os.Open(\"config.json\"), \"failed to open config\")\n    defer file.Close()\n\n    // Use file...\n}\n</code></pre>"},{"location":"excutils/recoverWithValue/","title":"RecoverWithValue","text":"<p><code>func RecoverWithValue[T any](fn func() T, defaultValue T) (result T)</code></p> <p>RecoverWithValue recovers from a panic and returns the specified default value.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    result := exc.RecoverWithValue(func() int {\n        panic(\"something went wrong\")\n        return 42\n    }, 0)\n\n    fmt.Println(result)  // 0 (default value returned due to panic)\n\n    // No panic\n    result = exc.RecoverWithValue(func() int {\n        return 42\n    }, 0)\n\n    fmt.Println(result)  // 42\n}\n</code></pre>"},{"location":"excutils/retry/","title":"Retry","text":"<p><code>func Retry(fn func() error, maxAttempts int) error</code></p> <p>Retry executes a function up to maxAttempts times, returning the first successful result. Returns the last error if all attempts fail. Returns an error if maxAttempts is less than 1.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    attempts := 0\n\n    err := exc.Retry(func() error {\n        attempts++\n        if attempts &lt; 3 {\n            return errors.New(\"temporary error\")\n        }\n        return nil\n    }, 5)\n\n    if err == nil {\n        fmt.Printf(\"Succeeded after %d attempts\\n\", attempts)\n    }\n}\n</code></pre>"},{"location":"excutils/retryWithResult/","title":"RetryWithResult","text":"<p><code>func RetryWithResult[T any](fn func() (T, error), maxAttempts int) (T, error)</code></p> <p>RetryWithResult executes a function up to maxAttempts times, returning the first successful result. Returns the result and error from the last attempt if all fail.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    attempts := 0\n\n    result, err := exc.RetryWithResult(func() (int, error) {\n        attempts++\n        if attempts &lt; 3 {\n            return 0, errors.New(\"temporary error\")\n        }\n        return 42, nil\n    }, 5)\n\n    if err == nil {\n        fmt.Printf(\"Got result: %d after %d attempts\\n\", result, attempts)\n    }\n}\n</code></pre>"},{"location":"excutils/returnAnyErr/","title":"ReturnAnyErr","text":"<p><code>func ReturnAnyErr(values ...any) error</code></p> <p>ReturnAnyErr returns the first error found in the list of values, if any. This is useful when dealing with variadic functions that may return errors.</p> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    err1 := errors.New(\"an error\")\n\n    // Find any error in mixed values\n    err := exc.ReturnAnyErr(42, \"hello\", err1, true)\n    fmt.Println(err)  // an error\n\n    // No errors\n    err = exc.ReturnAnyErr(42, \"hello\", true)\n    fmt.Println(err)  // &lt;nil&gt;\n}\n</code></pre>"},{"location":"excutils/returnNotNil/","title":"ReturnNotNil","text":"<p><code>func ReturnNotNil[T any](value *T, messages ...string) *T</code></p> <p>ReturnNotNil panics if the value is nil, otherwise returns the value. This is useful for asserting that a pointer must not be nil. The optional messages are formatted and included in the panic message.</p> <pre><code>package main\n\nimport (\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    numPtr := ptr.To(42)\n\n    // Returns value if not nil\n    result := exc.ReturnNotNil(numPtr, \"number must not be nil\")\n\n    // Panics if nil\n    var nilPtr *int\n    exc.ReturnNotNil(nilPtr, \"unexpected nil value\")  // panics\n}\n</code></pre>"},{"location":"excutils/try/","title":"Try","text":"<p><code>func Try(fn func() error) (err error)</code></p> <p>Try executes a function and returns its error. This is useful for defer statements or cleanup operations where you want to capture errors. Recovers from panics and converts them to errors.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    exc \"github.com/Goldziher/go-utils/excutils\"\n)\n\nfunc main() {\n    err := exc.Try(func() error {\n        // Code that might panic or return error\n        return riskyOperation()\n    })\n\n    if err != nil {\n        fmt.Printf(\"Caught error: %v\\n\", err)\n    }\n}\n\nfunc riskyOperation() error {\n    // ... may return error or panic\n    return nil\n}\n</code></pre>"},{"location":"maputils/","title":"maputils","text":"<p>Utilities for map transformations and operations.</p>"},{"location":"maputils/#overview","title":"Overview","text":"<p>The <code>maputils</code> package provides type-safe generic functions for working with maps. All functions leverage Go generics to work with any map type <code>map[K]V</code> where <code>K</code> is <code>comparable</code>.</p>"},{"location":"maputils/#functions","title":"Functions","text":"<p>Extraction: Keys, Values Transformation: Filter, Map Iteration: ForEach Combination: Merge Manipulation: Drop, Invert, Pick, Omit</p>"},{"location":"maputils/#example","title":"Example","text":"<pre><code>import \"github.com/Goldziher/go-utils/maputils\"\n\ndata := map[string]int{\n    \"apple\":  5,\n    \"banana\": 3,\n    \"cherry\": 8,\n}\n\n// Extract keys and values\nkeys := maputils.Keys(data)     // []string{\"apple\", \"banana\", \"cherry\"}\nvalues := maputils.Values(data) // []int{5, 3, 8}\n\n// Filter entries\nfiltered := maputils.Filter(data, func(k string, v int) bool {\n    return v &gt; 4\n})\n// Result: map[string]int{\"apple\": 5, \"cherry\": 8}\n\n// Transform map\ntransformed := maputils.Map(data, func(k string, v int) (string, string) {\n    return k, fmt.Sprintf(\"count: %d\", v)\n})\n// Result: map[string]string{\"apple\": \"count: 5\", ...}\n\n// Merge maps\nm1 := map[string]int{\"a\": 1, \"b\": 2}\nm2 := map[string]int{\"b\": 3, \"c\": 4}\nmerged := maputils.Merge(m1, m2)\n// Result: map[string]int{\"a\": 1, \"b\": 3, \"c\": 4}\n</code></pre>"},{"location":"maputils/drop/","title":"Drop","text":"<p><code>func Drop[K comparable, V any](mapInstance map[K]V, keys []K) map[K]V</code></p> <p>Drop takes a map with keys K and values V, and a slice of keys K, dropping all the key-value pairs that match the keys in the slice.</p> <p>Note: this function will modify the passed in map. To get a different object, use the Copy function to pass a copy to this function.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n        \"tomatoes\": 3,\n    }\n\n    // Drop will modify the original map\n    result := maputils.Drop(vegetables, []string{\"carrots\", \"tomatoes\"})\n\n    fmt.Print(result) // { \"potatoes\": 5 }\n    fmt.Print(vegetables) // { \"potatoes\": 5 } - original map was modified\n\n    // To avoid modifying the original, use Copy first\n    vegetables2 := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n        \"tomatoes\": 3,\n    }\n\n    copied := maputils.Copy(vegetables2)\n    result2 := maputils.Drop(copied, []string{\"carrots\"})\n\n    fmt.Print(result2) // { \"potatoes\": 5, \"tomatoes\": 3 }\n    fmt.Print(vegetables2) // { \"potatoes\": 5, \"carrots\": 10, \"tomatoes\": 3 } - original unchanged\n}\n</code></pre>"},{"location":"maputils/filter/","title":"Filter","text":"<p><code>func Filter[K comparable, V any](mapInstance map[K]V, function func(key K, value V) bool) map[K]V</code></p> <p>Filter takes a map with keys K and values V, and executes the passed in function for each key-value pair. If the filter function returns true, the key-value pair will be included in the output, otherwise it is filtered out.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    result := maputils.Filter(vegetables, func(key string, value int) bool {\n        return value == 5\n    })\n\n    fmt.Print(result) // { \"potatoes\": 5 }\n}\n</code></pre>"},{"location":"maputils/forEach/","title":"ForEach","text":"<p><code>func ForEach[K comparable, V any](mapInstance map[K]V, function func(key K, value V))</code></p> <p>ForEach given a map with keys K and values V, executes the passed in function for each key-value pair.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    maputils.ForEach(vegetables, func(key string, value int) {\n        fmt.Printf(\"Buy %d Kg of %s\", value, key) //  \"Buy 5 Kg of potatoes\", \"Buy 10 Kg of carrots\"\n    })\n}\n</code></pre>"},{"location":"maputils/fromEntries/","title":"FromEntries","text":"<p><code>func FromEntries[K comparable, V any](entries [][2]any) map[K]V</code></p> <p>FromEntries creates a map from a slice of key-value pairs. If duplicate keys exist, later values overwrite earlier ones.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    entries := [][2]any{\n        {\"name\", \"Alice\"},\n        {\"age\", 30},\n        {\"role\", \"admin\"},\n    }\n\n    user := maputils.FromEntries[string, any](entries)\n\n    fmt.Printf(\"%v\\n\", user)\n    // map[age:30 name:Alice role:admin]\n}\n</code></pre>"},{"location":"maputils/get/","title":"Get","text":"<p><code>func Get[K comparable, V any](mapInstance map[K]V, key K, defaultValue V) V</code></p> <p>Get safely gets a value from the map with a default fallback if the key doesn't exist.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    config := map[string]int{\n        \"maxConnections\": 100,\n        \"timeout\":        30,\n    }\n\n    // Get existing key\n    maxConn := maputils.Get(config, \"maxConnections\", 50)\n    fmt.Printf(\"Max connections: %d\\n\", maxConn) // 100\n\n    // Get missing key with default\n    bufferSize := maputils.Get(config, \"bufferSize\", 1024)\n    fmt.Printf(\"Buffer size: %d\\n\", bufferSize) // 1024\n}\n</code></pre>"},{"location":"maputils/groupBy/","title":"GroupBy","text":"<p><code>func GroupBy[K comparable, V any, G comparable](mapInstance map[K]V, grouper func(key K, value V) G) map[G]map[K]V</code></p> <p>GroupBy groups map entries by a grouping key generated from each entry. Returns a map where keys are group identifiers and values are maps of entries belonging to that group.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\":   95,\n        \"Bob\":     67,\n        \"Charlie\": 88,\n        \"David\":   72,\n        \"Eve\":     91,\n    }\n\n    // Group by grade (A: 90+, B: 80-89, C: 70-79, etc.)\n    byGrade := maputils.GroupBy(scores, func(name string, score int) string {\n        switch {\n        case score &gt;= 90:\n            return \"A\"\n        case score &gt;= 80:\n            return \"B\"\n        case score &gt;= 70:\n            return \"C\"\n        default:\n            return \"F\"\n        }\n    })\n\n    fmt.Printf(\"%v\\n\", byGrade)\n    // map[A:map[Alice:95 Eve:91] B:map[Charlie:88] C:map[Bob:67 David:72]]\n}\n</code></pre>"},{"location":"maputils/has/","title":"Has","text":"<p><code>func Has[K comparable, V any](mapInstance map[K]V, key K) bool</code></p> <p>Has checks if a key exists in the map. This is equivalent to the two-value form of map lookup but more expressive.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    config := map[string]string{\n        \"host\": \"localhost\",\n        \"port\": \"8080\",\n    }\n\n    if maputils.Has(config, \"host\") {\n        fmt.Println(\"Host is configured\")\n    }\n\n    if !maputils.Has(config, \"database\") {\n        fmt.Println(\"Database not configured\")\n    }\n}\n</code></pre>"},{"location":"maputils/invert/","title":"Invert","text":"<p><code>func Invert[K, V comparable](mapInstance map[K]V) map[V]K</code></p> <p>Invert swaps keys and values in a map. Both keys and values must be comparable types. If multiple keys have the same value, only one will remain (non-deterministic which one).</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    roles := map[string]int{\n        \"admin\": 1,\n        \"user\":  2,\n        \"guest\": 3,\n    }\n\n    // Invert to map from ID to role name\n    byID := maputils.Invert(roles)\n\n    fmt.Printf(\"%v\\n\", byID)\n    // map[1:admin 2:user 3:guest]\n}\n</code></pre>"},{"location":"maputils/keys/","title":"Keys","text":"<p><code>func Keys[K comparable, V any](mapInstance map[K]V) []K</code></p> <p>Keys takes a map with keys K and values V and returns a slice of type K with the map's keys.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    result := maputils.Keys(vegetables)\n\n    fmt.Print(result) // [\"potatoes\", \"carrots\"]\n}\n</code></pre>"},{"location":"maputils/map/","title":"Map","text":"<p><code>func Map[K comparable, V any, R any](mapInstance map[K]V, mapper func(key K, value V) R) map[K]R</code></p> <p>Map transforms map values using a mapper function, returning a new map with transformed values while preserving keys.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    prices := map[string]int{\n        \"apple\":  100,\n        \"banana\": 75,\n        \"cherry\": 200,\n    }\n\n    // Transform values to strings\n    priceStrings := maputils.Map(prices, func(k string, v int) string {\n        return fmt.Sprintf(\"$%d.%02d\", v/100, v%100)\n    })\n\n    fmt.Printf(\"%v\\n\", priceStrings)\n    // map[apple:$1.00 banana:$0.75 cherry:$2.00]\n}\n</code></pre>"},{"location":"maputils/mapKeys/","title":"MapKeys","text":"<p><code>func MapKeys[K comparable, V any, R comparable](mapInstance map[K]V, mapper func(key K, value V) R) map[R]V</code></p> <p>MapKeys transforms map keys using a mapper function, returning a new map with transformed keys. If the mapper produces duplicate keys, later values will overwrite earlier ones.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    data := map[string]int{\n        \"apple\":  5,\n        \"BANANA\": 3,\n        \"Cherry\": 8,\n    }\n\n    // Normalize keys to lowercase\n    normalized := maputils.MapKeys(data, func(k string, v int) string {\n        return strings.ToLower(k)\n    })\n\n    fmt.Printf(\"%v\\n\", normalized)\n    // map[apple:5 banana:3 cherry:8]\n}\n</code></pre>"},{"location":"maputils/merge/","title":"Merge","text":"<p><code>func Merge[K comparable, V any](mapInstances ...map[K]V) map[K]V</code></p> <p>Merge takes a variadic numbers of maps with keys K and values V and returns a merged map. Merging is done from left to right. If a key already exists in a previous map, its value is over-written.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n        \"tomatoes\": 3,\n    }\n\n    fruits := map[string]int{\n        \"bananas\":  3,\n        \"tomatoes\": 5,\n    }\n\n    result := maputils.Merge(vegetables, fruits)\n\n    fmt.Print(result) //{ \"potatoes\": 5, \"carrots\":  10, \"tomatoes\": 5, \"bananas\": 3 }\n}\n</code></pre>"},{"location":"maputils/omit/","title":"Omit","text":"<p><code>func Omit[K comparable, V any](mapInstance map[K]V, keys []K) map[K]V</code></p> <p>Omit creates a new map excluding the specified keys. This is the opposite of Pick.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    user := map[string]any{\n        \"name\":     \"Alice\",\n        \"age\":      30,\n        \"email\":    \"alice@example.com\",\n        \"password\": \"secret\",\n        \"role\":     \"admin\",\n    }\n\n    // Remove sensitive fields\n    safe := maputils.Omit(user, []string{\"password\"})\n\n    fmt.Printf(\"%v\\n\", safe)\n    // map[age:30 email:alice@example.com name:Alice role:admin]\n}\n</code></pre>"},{"location":"maputils/pick/","title":"Pick","text":"<p><code>func Pick[K comparable, V any](mapInstance map[K]V, keys []K) map[K]V</code></p> <p>Pick creates a new map containing only the specified keys. Keys that don't exist in the original map are ignored.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    user := map[string]any{\n        \"name\":     \"Alice\",\n        \"age\":      30,\n        \"email\":    \"alice@example.com\",\n        \"password\": \"secret\",\n        \"role\":     \"admin\",\n    }\n\n    // Pick only public fields\n    public := maputils.Pick(user, []string{\"name\", \"age\", \"role\"})\n\n    fmt.Printf(\"%v\\n\", public)\n    // map[age:30 name:Alice role:admin]\n}\n</code></pre>"},{"location":"maputils/toEntries/","title":"ToEntries","text":"<p><code>func ToEntries[K comparable, V any](mapInstance map[K]V) [][2]any</code></p> <p>ToEntries converts a map to a slice of key-value pairs. Order is non-deterministic due to map iteration order.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    scores := map[string]int{\n        \"Alice\": 95,\n        \"Bob\":   87,\n        \"Charlie\": 92,\n    }\n\n    entries := maputils.ToEntries(scores)\n\n    for _, entry := range entries {\n        name := entry[0].(string)\n        score := entry[1].(int)\n        fmt.Printf(\"%s: %d\\n\", name, score)\n    }\n}\n</code></pre>"},{"location":"maputils/values/","title":"Values","text":"<p><code>func Values[K comparable, V any](mapInstance map[K]V) []V</code></p> <p>Values takes a map with keys K and values V and returns a slice of type V with the map's values.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/maputils\"\n)\n\nfunc main() {\n    vegetables := map[string]int{\n        \"potatoes\": 5,\n        \"carrots\":  10,\n    }\n\n    result := maputils.Values(vegetables)\n\n    fmt.Print(result) // [5, 10]\n}\n</code></pre>"},{"location":"mathutils/","title":"mathutils","text":"<p>Generic math operations with type constraints.</p>"},{"location":"mathutils/#overview","title":"Overview","text":"<p>The <code>mathutils</code> package provides mathematical utilities that work with generic numeric types through Go generics and constraints. All functions use appropriate type constraints (<code>cmp.Ordered</code>, <code>constraints.Integer</code>, etc.) for compile-time type safety.</p>"},{"location":"mathutils/#functions","title":"Functions","text":"<p>Range Operations: Clamp, InRange Numeric Operations: Abs, Average Number Theory: Gcd, Lcm, IsPrime</p>"},{"location":"mathutils/#example","title":"Example","text":"<pre><code>import \"github.com/Goldziher/go-utils/mathutils\"\n\n// Clamp values to a range\nclamped := mathutils.Clamp(150, 0, 100)  // 100\n\n// Check if value is in range\ninRange := mathutils.InRange(50, 0, 100)  // true\n\n// Number theory\ngcd := mathutils.Gcd(48, 18)   // 6\nlcm := mathutils.Lcm(4, 6)     // 12\nprime := mathutils.IsPrime(17)  // true\n\n// Statistics\nvalues := []int{1, 2, 3, 4, 5}\navg := mathutils.Average(values)  // 3.0\n</code></pre>"},{"location":"mathutils/abs/","title":"Abs","text":"<p><code>func Abs[T Number](value T) T</code></p> <p>Abs returns the absolute value of a number. For unsigned types, returns the value as-is.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/mathutils\"\n)\n\nfunc main() {\n    fmt.Println(mathutils.Abs(5))     // 5\n    fmt.Println(mathutils.Abs(-5))    // 5\n    fmt.Println(mathutils.Abs(0))     // 0\n    fmt.Println(mathutils.Abs(-3.5))  // 3.5\n}\n</code></pre>"},{"location":"mathutils/average/","title":"Average","text":"<p><code>func Average[T Number](values []T) float64</code></p> <p>Average returns the average (mean) of all values in a slice. Returns 0 for empty slice.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/mathutils\"\n)\n\nfunc main() {\n    integers := []int{1, 2, 3, 4, 5}\n    fmt.Println(mathutils.Average(integers))  // 3.0\n\n    floats := []float64{2.5, 7.5}\n    fmt.Println(mathutils.Average(floats))  // 5.0\n\n    empty := []int{}\n    fmt.Println(mathutils.Average(empty))  // 0.0\n}\n</code></pre>"},{"location":"mathutils/clamp/","title":"Clamp","text":"<p><code>func Clamp[T cmp.Ordered](value, min, max T) T</code></p> <p>Clamp restricts a value to be within a specified range. If value &lt; min, returns min. If value &gt; max, returns max. Otherwise returns value.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/mathutils\"\n)\n\nfunc main() {\n    // Clamp integers\n    fmt.Println(mathutils.Clamp(5, 0, 10))   // 5\n    fmt.Println(mathutils.Clamp(-5, 0, 10))  // 0\n    fmt.Println(mathutils.Clamp(15, 0, 10))  // 10\n\n    // Clamp floats\n    fmt.Println(mathutils.Clamp(2.5, 0.0, 5.0))  // 2.5\n    fmt.Println(mathutils.Clamp(6.0, 0.0, 5.0))  // 5.0\n}\n</code></pre>"},{"location":"mathutils/gcd/","title":"Gcd","text":"<p><code>func Gcd[T constraints.Integer](a, b T) T</code></p> <p>Gcd returns the greatest common divisor of two integers using the Euclidean algorithm.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/mathutils\"\n)\n\nfunc main() {\n    fmt.Println(mathutils.Gcd(48, 18))   // 6\n    fmt.Println(mathutils.Gcd(17, 13))   // 1\n    fmt.Println(mathutils.Gcd(10, 5))    // 5\n    fmt.Println(mathutils.Gcd(-12, 24))  // 12 (always returns positive)\n    fmt.Println(mathutils.Gcd(7, 0))     // 7\n}\n</code></pre>"},{"location":"mathutils/inRange/","title":"InRange","text":"<p><code>func InRange[T cmp.Ordered](value, min, max T) bool</code></p> <p>InRange checks if a value is within a range [min, max] (inclusive).</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/mathutils\"\n)\n\nfunc main() {\n    fmt.Println(mathutils.InRange(5, 0, 10))    // true\n    fmt.Println(mathutils.InRange(0, 0, 10))    // true (inclusive)\n    fmt.Println(mathutils.InRange(10, 0, 10))   // true (inclusive)\n    fmt.Println(mathutils.InRange(-1, 0, 10))   // false\n    fmt.Println(mathutils.InRange(11, 0, 10))   // false\n}\n</code></pre>"},{"location":"mathutils/isPrime/","title":"IsPrime","text":"<p><code>func IsPrime[T constraints.Integer](n T) bool</code></p> <p>IsPrime checks if a number is prime. Returns false for numbers less than 2.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/mathutils\"\n)\n\nfunc main() {\n    // Prime numbers\n    fmt.Println(mathutils.IsPrime(2))   // true\n    fmt.Println(mathutils.IsPrime(3))   // true\n    fmt.Println(mathutils.IsPrime(17))  // true\n    fmt.Println(mathutils.IsPrime(19))  // true\n\n    // Non-prime numbers\n    fmt.Println(mathutils.IsPrime(0))   // false\n    fmt.Println(mathutils.IsPrime(1))   // false\n    fmt.Println(mathutils.IsPrime(4))   // false\n    fmt.Println(mathutils.IsPrime(15))  // false\n}\n</code></pre>"},{"location":"mathutils/lcm/","title":"Lcm","text":"<p><code>func Lcm[T constraints.Integer](a, b T) T</code></p> <p>Lcm returns the least common multiple of two integers.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/mathutils\"\n)\n\nfunc main() {\n    fmt.Println(mathutils.Lcm(4, 6))    // 12\n    fmt.Println(mathutils.Lcm(17, 13))  // 221\n    fmt.Println(mathutils.Lcm(10, 5))   // 10\n    fmt.Println(mathutils.Lcm(0, 5))    // 0\n    fmt.Println(mathutils.Lcm(5, 0))    // 0\n}\n</code></pre>"},{"location":"ptrutils/","title":"ptrutils","text":"<p>Pointer utilities for safe pointer operations and conversions.</p>"},{"location":"ptrutils/#overview","title":"Overview","text":"<p>The <code>ptrutils</code> package (imported as <code>ptr</code>) provides utilities for working with pointers, including creating pointers to literals, safe dereferencing, and pointer slice operations.</p>"},{"location":"ptrutils/#functions","title":"Functions","text":"<p>Creation: To Dereferencing: Deref, DerefSlice Comparison: Equal, IsNil Utilities: Coalesce, ToSlice, NonNilSlice, ToPointerSlice</p>"},{"location":"ptrutils/#example","title":"Example","text":"<pre><code>import ptr \"github.com/Goldziher/go-utils/ptrutils\"\n\n// Create pointers to literals\nnumPtr := ptr.To(42)\nstrPtr := ptr.To(\"hello\")\n\n// Safe dereferencing with default\nvalue := ptr.Deref(numPtr, 0)  // 42\nnilValue := ptr.Deref((*int)(nil), 99)  // 99\n\n// Coalesce - get first non-nil\nfirst := ptr.Coalesce(nil, nil, ptr.To(5), ptr.To(10))  // *5\n\n// Convert slice to pointer slice\nvalues := []int{1, 2, 3}\nptrs := ptr.ToPointerSlice(values)  // []*int\n</code></pre>"},{"location":"ptrutils/coalesce/","title":"Coalesce","text":"<p><code>func Coalesce[T any](ptrs ...*T) *T</code></p> <p>Coalesce returns the first non-nil pointer from the list. Returns nil if all pointers are nil.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    var a, b *int\n    c := ptr.To(42)\n    d := ptr.To(99)\n\n    // Get first non-nil pointer\n    result := ptr.Coalesce(a, b, c, d)\n    fmt.Println(*result)  // 42\n\n    // All nil\n    result = ptr.Coalesce((*int)(nil), (*int)(nil))\n    fmt.Println(result)  // &lt;nil&gt;\n}\n</code></pre>"},{"location":"ptrutils/deref/","title":"Deref","text":"<p><code>func Deref[T any](ptr *T, def T) T</code></p> <p>Deref dereferences ptr and returns the value it points to if not nil, or else returns def (the default value). This provides safe pointer dereferencing without nil checks.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    numPtr := ptr.To(42)\n    value := ptr.Deref(numPtr, 0)\n    fmt.Println(value)  // 42\n\n    // Safe handling of nil pointers\n    var nilPtr *int\n    defaultValue := ptr.Deref(nilPtr, 99)\n    fmt.Println(defaultValue)  // 99\n}\n</code></pre>"},{"location":"ptrutils/derefSlice/","title":"DerefSlice","text":"<p><code>func DerefSlice[T any](ptrs []*T, def T) []T</code></p> <p>DerefSlice dereferences all pointers in a slice, using def for nil pointers. Returns a new slice with dereferenced values.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    ptrs := []*int{ptr.To(1), nil, ptr.To(3), nil, ptr.To(5)}\n\n    // Dereference with default value of 0 for nils\n    values := ptr.DerefSlice(ptrs, 0)\n    fmt.Println(values)  // [1 0 3 0 5]\n}\n</code></pre>"},{"location":"ptrutils/equal/","title":"Equal","text":"<p><code>func Equal[T comparable](a, b *T) bool</code></p> <p>Equal compares two pointers for equality. Returns true if both are nil or both point to equal values. Returns false if one is nil and the other is not.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    a := ptr.To(5)\n    b := ptr.To(5)\n    c := ptr.To(10)\n    var d *int\n\n    fmt.Println(ptr.Equal(a, b))  // true (same values)\n    fmt.Println(ptr.Equal(a, c))  // false (different values)\n    fmt.Println(ptr.Equal(a, d))  // false (one nil, one not)\n    fmt.Println(ptr.Equal((*int)(nil), (*int)(nil)))  // true (both nil)\n}\n</code></pre>"},{"location":"ptrutils/isNil/","title":"IsNil","text":"<p><code>func IsNil[T any](ptr *T) bool</code></p> <p>IsNil checks if a pointer is nil. This is a convenience function for readability.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    numPtr := ptr.To(42)\n    var nilPtr *int\n\n    fmt.Println(ptr.IsNil(numPtr))  // false\n    fmt.Println(ptr.IsNil(nilPtr))  // true\n}\n</code></pre>"},{"location":"ptrutils/nonNilSlice/","title":"NonNilSlice","text":"<p><code>func NonNilSlice[T any](ptrs []*T) []*T</code></p> <p>NonNilSlice returns a new slice containing only non-nil pointers from the input.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    ptrs := []*int{ptr.To(1), nil, ptr.To(3), nil, ptr.To(5)}\n\n    // Filter out nil pointers\n    nonNil := ptr.NonNilSlice(ptrs)\n    fmt.Printf(\"Length: %d\\n\", len(nonNil))  // 3\n\n    for _, p := range nonNil {\n        fmt.Println(*p)  // 1, 3, 5\n    }\n}\n</code></pre>"},{"location":"ptrutils/to/","title":"To","text":"<p><code>func To[T any](v T) *T</code></p> <p>To returns a pointer to the given value. This is useful for creating pointers to literals or values in a single expression.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    // Create pointers to literals\n    numPtr := ptr.To(42)\n    strPtr := ptr.To(\"hello\")\n    boolPtr := ptr.To(true)\n\n    fmt.Printf(\"%v, %v, %v\\n\", *numPtr, *strPtr, *boolPtr)\n    // 42, hello, true\n\n    // Useful for struct fields that require pointers\n    type Config struct {\n        MaxRetries *int\n    }\n    config := Config{MaxRetries: ptr.To(5)}\n}\n</code></pre>"},{"location":"ptrutils/toPointerSlice/","title":"ToPointerSlice","text":"<p><code>func ToPointerSlice[T any](values []T) []*T</code></p> <p>ToPointerSlice converts a slice of values to a slice of pointers. Each element in the result points to the corresponding element in the input.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    values := []int{1, 2, 3, 4, 5}\n\n    // Convert to pointer slice\n    ptrs := ptr.ToPointerSlice(values)\n\n    for _, p := range ptrs {\n        fmt.Println(*p)  // 1, 2, 3, 4, 5\n    }\n}\n</code></pre>"},{"location":"ptrutils/toSlice/","title":"ToSlice","text":"<p><code>func ToSlice[T any](ptr *T) []T</code></p> <p>ToSlice converts a pointer to a slice. Returns an empty slice if ptr is nil, otherwise returns a slice with the single element.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    ptr \"github.com/Goldziher/go-utils/ptrutils\"\n)\n\nfunc main() {\n    numPtr := ptr.To(42)\n    slice := ptr.ToSlice(numPtr)\n    fmt.Println(slice)  // [42]\n\n    var nilPtr *int\n    emptySlice := ptr.ToSlice(nilPtr)\n    fmt.Println(emptySlice)  // []\n}\n</code></pre>"},{"location":"sliceutils/","title":"sliceutils","text":"<p>Functional programming utilities for slices, inspired by JavaScript Array methods and LINQ.</p>"},{"location":"sliceutils/#overview","title":"Overview","text":"<p>The <code>sliceutils</code> package provides type-safe generic functions for slice manipulation. All functions work with any slice type through Go generics and accept callback functions following JavaScript's Array method conventions (value, index, slice).</p>"},{"location":"sliceutils/#categories","title":"Categories","text":"<p>Functional Operations: Map, Filter, Reduce, ForEach Search Operations: Find, FindIndex, FindIndexes, FindLastIndex Predicates: Some, Every Set Operations: Union, Intersection, Difference, Unique Transformations: Reverse, Flatten, FlatMap, Chunk, Pluck LINQ-style: GroupBy, Partition, DistinctBy, CountBy, MinBy, MaxBy Utilities: Remove, EnsureUniqueAndAppend, Sum</p>"},{"location":"sliceutils/#when-to-use-stdlib-vs-sliceutils","title":"When to use stdlib vs sliceutils","text":"<p>Use stdlib <code>slices</code> for: - <code>slices.Index(slice, value)</code> - find index of value - <code>slices.Contains(slice, value)</code> - check if slice contains value - <code>slices.Clone(slice)</code> - copy a slice - <code>slices.Concat(slices...)</code> - merge slices - <code>slices.Sort(slice)</code> - sort a slice</p> <p>Use sliceutils for: - Functional patterns with callbacks (Map, Filter, Reduce) - LINQ-style operations (GroupBy, Partition, DistinctBy) - Complex search operations (FindIndex with predicate) - Set operations (Union, Intersection, Difference)</p>"},{"location":"sliceutils/#example","title":"Example","text":"<pre><code>import \"github.com/Goldziher/go-utils/sliceutils\"\n\nnumbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n// Functional patterns\nevens := sliceutils.Filter(numbers, func(v, i int, s []int) bool {\n    return v%2 == 0\n})\n\ndoubled := sliceutils.Map(evens, func(v, i int, s []int) int {\n    return v * 2\n})\n\nsum := sliceutils.Reduce(doubled, func(acc, v, i int, s []int) int {\n    return acc + v\n}, 0)\n\n// LINQ-style operations\ntype User struct {\n    Name string\n    Age  int\n    Role string\n}\n\nusers := []User{\n    {\"Alice\", 30, \"admin\"},\n    {\"Bob\", 25, \"user\"},\n    {\"Charlie\", 30, \"user\"},\n}\n\n// Group by age\nbyAge := sliceutils.GroupBy(users, func(u User) int {\n    return u.Age\n})\n\n// Partition by role\nadmins, regularUsers := sliceutils.Partition(users, func(u User) bool {\n    return u.Role == \"admin\"\n})\n\n// Get distinct ages\nages := sliceutils.Map(users, func(u User, i int, s []User) int {\n    return u.Age\n})\nuniqueAges := sliceutils.Unique(ages)\n</code></pre>"},{"location":"sliceutils/chunk/","title":"Chunk","text":"<p><code>func Chunk[T any](input []T, size int) [][]T</code></p> <p>Unique takes a slice of type T and size N and returns a slice of slices T of size N.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    result1 := sliceutils.Chunk(numbers, 2) // [][]int{{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}}\n    result2 := sliceutils.Chunk(numbers, 3) // [][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10}}\n}\n</code></pre>"},{"location":"sliceutils/compact/","title":"Compact","text":"<p><code>func Compact[T comparable](slice []T) []T</code></p> <p>Compact removes all zero values from the slice. A zero value is determined by the zero value of type T (0 for numbers, \"\" for strings, nil for pointers, false for bools, etc.).</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    // Remove zero numbers\n    numbers := []int{1, 0, 2, 0, 3, 0, 4, 5}\n    compacted := sliceutils.Compact(numbers)\n    fmt.Printf(\"%v\\n\", compacted) // [1 2 3 4 5]\n\n    // Remove empty strings\n    strings := []string{\"hello\", \"\", \"world\", \"\", \"!\"}\n    compactedStrings := sliceutils.Compact(strings)\n    fmt.Printf(\"%v\\n\", compactedStrings) // [hello world !]\n}\n</code></pre>"},{"location":"sliceutils/countBy/","title":"CountBy","text":"<p><code>func CountBy[T any, K comparable](slice []T, keySelector func(T) K) map[K]int</code></p> <p>CountBy counts the occurrences of each key extracted using the keySelector function. Returns a map where keys are the extracted keys and values are the counts.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    words := []string{\"apple\", \"banana\", \"apricot\", \"blueberry\", \"avocado\"}\n\n    // Count words by first letter\n    counts := sliceutils.CountBy(words, func(word string) rune {\n        return rune(word[0])\n    })\n\n    fmt.Printf(\"%v\\n\", counts)\n    // map[97:3 98:2] (a=3, b=2)\n}\n</code></pre>"},{"location":"sliceutils/difference/","title":"Difference","text":"<p><code>func Difference[T comparable](slices ...[]T) []T</code></p> <p>Difference takes a variadic number of slices of type T and returns a slice of type T containing the elements that are different between the slices.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    first, second := []int{1, 2, 3}, []int{1, 7, 3}\n\n    result := sliceutils.Difference(first, second)\n\n    fmt.Print(result) // [2, 7]\n}\n</code></pre>"},{"location":"sliceutils/distinctBy/","title":"DistinctBy","text":"<p><code>func DistinctBy[T any, K comparable](slice []T, keySelector func(T) K) []T</code></p> <p>DistinctBy returns a slice containing only the first occurrence of each element, where uniqueness is determined by the key returned from the keySelector function.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    type User struct {\n        Name string\n        Age  int\n    }\n\n    users := []User{\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 30},\n        {\"David\", 25},\n    }\n\n    // Get users with distinct ages (first occurrence only)\n    distinctByAge := sliceutils.DistinctBy(users, func(u User) int {\n        return u.Age\n    })\n\n    fmt.Printf(\"%v\\n\", distinctByAge)\n    // [{Alice 30} {Bob 25}]\n}\n</code></pre>"},{"location":"sliceutils/ensureUniqueAndAppend/","title":"EnsureUniqueAndAppend","text":"<p><code>func EnsureUniqueAndAppend[T comparable](slice []T, item T) []T</code></p> <p>EnsureUniqueAndAppend appends an item to a slice if it does not already exists.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    slice := []string{}\n    item := \"go-utils\"\n\n    slice = sliceutils.EnsureUniqueAndAppend(slice, item) // [\"go-utils\"]\n    slice = sliceutils.EnsureUniqueAndAppend(slice, item) // [\"go-utils\"]\n}\n</code></pre>"},{"location":"sliceutils/every/","title":"Every","text":"<p><code>func Every[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool</code></p> <p>Every takes a slice of type T and a predicate function, returning true if the predicate returned true for every elements. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.Every(friends, func(value string, index int, slice []string) bool {\n        return value == \"Mandy\"\n    })\n\n    fmt.Print(result) // false\n}\n</code></pre>"},{"location":"sliceutils/filter/","title":"Filter","text":"<p><code>func Filter[T any](slice []T, predicate func(value T, index int, slice []T) bool) []T</code></p> <p>Filter takes a slice of type <code>T</code> and filters it using the given predicate function. The predicate is passed the current element, the current index and the slice as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    oddNumbers := sliceutils.Filter(numerals, func(value int, index int, slice []int) bool {\n        return value%2 != 0\n    })\n\n    fmt.Printf(\"%v\", oddNumbers) // [1 3 5 7 9]\n}\n</code></pre>"},{"location":"sliceutils/find/","title":"Find","text":"<p><code>func Find[T any](slice []T, predicate func(value T, index int, slice []T) bool) *T</code></p> <p>Find takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, a pointer to the element is returned. If no element is found, nil is returned. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    days := []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}\n\n    result := sliceutils.Find(days, func(value string, index int, slice []string) bool {\n        return strings.Contains(value, \"Wed\")\n    })\n\n    fmt.Print(result) // \"Wednesday\"\n}\n</code></pre>"},{"location":"sliceutils/findIndex/","title":"FindIndex","text":"<p><code>func FindIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int</code></p> <p>FindIndex takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, the element's index is returned. If no element is found, <code>-1</code> is returned. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    days := []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}\n\n    result := sliceutils.FindIndex(days, func(value string, index int, slice []string) bool {\n        return strings.Contains(value, \"Wed\")\n    })\n\n    fmt.Print(result) // 3\n}\n</code></pre>"},{"location":"sliceutils/findIndexes/","title":"FindIndexes","text":"<p><code>func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int</code></p> <p>FindIndexes takes a slice of type T and executes the passed in predicate function for each element in the slice, returning a slice containing all indexes for which the predicate returned true. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindIndexes(friends, func(value string, index int, slice []string) bool {\n        return value == \"John\"\n    })\n\n    fmt.Print(result) // [0, 4]\n}\n</code></pre>"},{"location":"sliceutils/findIndexesOf/","title":"FindIndexesOf","text":"<p><code>func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int</code></p> <p>FindIndexesOf takes a slice of type T and a value of type T, returning a slice containing all indexes where elements equal the passed in value.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindIndexesOf(friends, \"John\")\n\n    fmt.Print(result) // [0, 4]\n}\n</code></pre>"},{"location":"sliceutils/findLastIndex/","title":"FindLastIndex","text":"<p><code>func FindLastIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int</code></p> <p>FindLastIndex takes a slice of type T and executes the passed in predicate function for each element in the slice starting from its end. If the predicate returns true, the element's index is returned. If no element is found, <code>-1</code> is returned. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindLastIndex(friends, func(value string, index int, slice []string) bool {\n        return value == \"John\"\n    })\n\n    fmt.Print(result) // 4\n}\n</code></pre>"},{"location":"sliceutils/findLastIndexOf/","title":"FindLastIndexOf","text":"<p><code>func FindLastIndexOf[T comparable](slice []T, value T) int</code></p> <p>FindLastIndexOf takes a slice of type T and a value of type T. If any element in the slice equals the given value, the last index of is occurrence is returned. If no element is found, <code>-1</code> is returned.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.FindLastIndexOf(friends, \"John\")\n\n    fmt.Print(result) // 4\n}\n</code></pre>"},{"location":"sliceutils/flatMap/","title":"FlatMap","text":"<p><code>func FlatMap[T any, R any](slice []T, mapper func(value T, index int, slice []T) []R) []R</code></p> <p>FlatMap receives a slice of type T, executes the passed in slice-mapper function for each element in the slice, and returns a flattened slice containing all the elements from all the mapped slices. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    items := []int{1, 2, 3, 4}\n\n    flatMapped := sliceutils.FlatMap(items, func(value int, index int, slice []int) []int {\n        return []int{value, value * 2}\n    }) // []int{1, 2, 2, 4, 3, 6, 4, 8}\n}\n</code></pre>"},{"location":"sliceutils/flatten/","title":"Flatten","text":"<p><code>Flatten[I any](input [][]I) []I</code></p> <p>Flatten - receives a slice of slice of type I and flattens it to a slice of type I.</p> <pre><code>package main\n\nimport (\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    items := [][]int{\n        {1, 2, 3, 4},\n        {5, 6},\n        {7, 8},\n        {9, 10, 11},\n    }\n\n    flattened := sliceutils.Flatten(items) //[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}\n}\n</code></pre>"},{"location":"sliceutils/forEach/","title":"ForEach","text":"<p><code>func ForEach[T any](slice []T, function func(value T, index int, slice []T))</code></p> <p>ForEach executes the passed in function for each element in the given slice. The function is passed the current element, the current index and the slice as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    result := 0\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    sliceutils.ForEach(numerals, func(value int, index int, slice []int) {\n        result += value\n    })\n\n    fmt.Print(result) // 45\n}\n</code></pre>"},{"location":"sliceutils/groupBy/","title":"GroupBy","text":"<p><code>func GroupBy[T any, K comparable](slice []T, keySelector func(T) K) map[K][]T</code></p> <p>GroupBy groups elements of a slice by a key extracted using the keySelector function. Returns a map where keys are the grouping keys and values are slices of elements that share that key. This is a LINQ-style operation useful for categorizing or organizing data.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    type User struct {\n        Name string\n        Age  int\n    }\n\n    users := []User{\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 30},\n        {\"David\", 25},\n    }\n\n    // Group users by age\n    byAge := sliceutils.GroupBy(users, func(u User) int {\n        return u.Age\n    })\n\n    fmt.Printf(\"%v\\n\", byAge)\n    // map[25:[{Bob 25} {David 25}] 30:[{Alice 30} {Charlie 30}]]\n}\n</code></pre>"},{"location":"sliceutils/head/","title":"Head","text":"<p><code>func Head[T any](slice []T) *T</code></p> <p>Head returns a pointer to the first element of the slice. Returns nil if the slice is empty.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    first := sliceutils.Head(numbers)\n    if first != nil {\n        fmt.Printf(\"First: %d\\n\", *first) // First: 1\n    }\n\n    empty := []int{}\n    noFirst := sliceutils.Head(empty)\n    fmt.Printf(\"Empty slice head: %v\\n\", noFirst) // nil\n}\n</code></pre>"},{"location":"sliceutils/initial/","title":"Initial","text":"<p><code>func Initial[T any](slice []T) []T</code></p> <p>Initial returns all elements of the slice except the last. Returns an empty slice if the slice has 0 or 1 elements.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    allButLast := sliceutils.Initial(numbers)\n    fmt.Printf(\"%v\\n\", allButLast) // [1 2 3 4]\n\n    single := []int{1}\n    emptyInitial := sliceutils.Initial(single)\n    fmt.Printf(\"%v\\n\", emptyInitial) // []\n}\n</code></pre>"},{"location":"sliceutils/intersection/","title":"Intersection","text":"<p><code>func Intersection[T comparable](slices ...[]T) []T</code></p> <p>Intersection takes a variadic number of slices of type T and returns a slice of type T containing any values that are common to all slices.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    first, second := []int{1, 2, 3}, []int{1, 7, 3}\n\n    result := sliceutils.Intersection(first, second)\n\n    fmt.Print(result) // [1, 3]\n}\n</code></pre>"},{"location":"sliceutils/last/","title":"Last","text":"<p><code>func Last[T any](slice []T) *T</code></p> <p>Last returns a pointer to the last element of the slice. Returns nil if the slice is empty.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    lastElem := sliceutils.Last(numbers)\n    if lastElem != nil {\n        fmt.Printf(\"Last: %d\\n\", *lastElem) // Last: 5\n    }\n\n    empty := []int{}\n    noLast := sliceutils.Last(empty)\n    fmt.Printf(\"Empty slice last: %v\\n\", noLast) // nil\n}\n</code></pre>"},{"location":"sliceutils/map/","title":"Map","text":"<p><code>func Map[T any, R any](slice []T, mapper func(value T, index int, slice []T) R) (mapped []R)</code></p> <p>Map allows transforming the values in a slice by executing the given mapper function for each element in the slice. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    result := sliceutils.Map(numerals, func(value int, index int, slice []int) int {\n        return value * 2\n    })\n\n    fmt.Print(result) // [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n}\n</code></pre>"},{"location":"sliceutils/maxBy/","title":"MaxBy","text":"<p><code>func MaxBy[T any, O cmp.Ordered](slice []T, selector func(T) O) *T</code></p> <p>MaxBy returns a pointer to the element with the maximum value as determined by the selector function. Returns nil if the slice is empty.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    type Product struct {\n        Name  string\n        Price float64\n    }\n\n    products := []Product{\n        {\"Apple\", 1.50},\n        {\"Banana\", 0.75},\n        {\"Cherry\", 2.00},\n    }\n\n    expensive := sliceutils.MaxBy(products, func(p Product) float64 {\n        return p.Price\n    })\n\n    if expensive != nil {\n        fmt.Printf(\"Most expensive: %s at $%.2f\\n\", expensive.Name, expensive.Price)\n        // Most expensive: Cherry at $2.00\n    }\n}\n</code></pre>"},{"location":"sliceutils/minBy/","title":"MinBy","text":"<p><code>func MinBy[T any, O cmp.Ordered](slice []T, selector func(T) O) *T</code></p> <p>MinBy returns a pointer to the element with the minimum value as determined by the selector function. Returns nil if the slice is empty.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    type Product struct {\n        Name  string\n        Price float64\n    }\n\n    products := []Product{\n        {\"Apple\", 1.50},\n        {\"Banana\", 0.75},\n        {\"Cherry\", 2.00},\n    }\n\n    cheapest := sliceutils.MinBy(products, func(p Product) float64 {\n        return p.Price\n    })\n\n    if cheapest != nil {\n        fmt.Printf(\"Cheapest: %s at $%.2f\\n\", cheapest.Name, cheapest.Price)\n        // Cheapest: Banana at $0.75\n    }\n}\n</code></pre>"},{"location":"sliceutils/partition/","title":"Partition","text":"<p><code>func Partition[T any](slice []T, predicate func(T) bool) (truthy []T, falsy []T)</code></p> <p>Partition splits a slice into two slices based on a predicate function. The first slice contains elements for which the predicate returns true, the second contains elements for which it returns false.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Partition into evens and odds\n    evens, odds := sliceutils.Partition(numbers, func(n int) bool {\n        return n%2 == 0\n    })\n\n    fmt.Printf(\"Evens: %v\\n\", evens) // [2 4 6 8 10]\n    fmt.Printf(\"Odds: %v\\n\", odds)   // [1 3 5 7 9]\n}\n</code></pre>"},{"location":"sliceutils/pluck/","title":"Pluck","text":"<p><code>func Pluck[I any, O any](input []I, getter func(I) *O) []O</code></p> <p>Pluck receives a slice of type I and a getter func to a field and returns an array containing requested field from each slice's item.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    items := []Pluckable{\n        {\n            Code:  \"azer\",\n            Value: \"Azer\",\n        },\n        {\n            Code:  \"tyuio\",\n            Value: \"Tyuio\",\n        },\n    }\n\n    result1 := sliceutils.Pluck(items, func(item Pluckable) *string {\n        return &amp;item.Code\n    }) // []string{\"azer\", \"tyuio\"\"}\n    result2 := sliceutils.Pluck(items, func(item Pluckable) *string {\n        return &amp;item.Value\n    }) // []string{\"Azer\", \"Tyuio\"}\n}\n</code></pre>"},{"location":"sliceutils/reduce/","title":"Reduce","text":"<p><code>func Reduce[T any, R any](slice []T, reducer func(acc R, value T, index int, slice []T) R, initial R) R</code></p> <p>Reduce allows transforming the slice and its values into a different value by executing the given reducer function for each element in the slice. The function is passed the accumulator, current element, current index and the slice as function arguments. The third argument to reduce is the initial value.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    sum := sliceutils.Reduce(\n        numerals,\n        func(acc int, cur int, index int, slice []int) int {\n            return acc + cur\n        },\n        0,\n    )\n\n    fmt.Print(sum) // 45\n}\n</code></pre>"},{"location":"sliceutils/remove/","title":"Remove","text":"<p><code>func Remove[T any](slice []T, i int) []T</code></p> <p>Remove takes a slice of type T and an index, removing the element at the given index.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    numerals = sliceutils.Remove(numerals, 3)\n\n    fmt.Print(numerals) // [0, 1, 2, 4, 5, 6, 7, 8, 9]\n}\n</code></pre>"},{"location":"sliceutils/reverse/","title":"Reverse","text":"<p><code>func Reverse[T any](slice []T) []T</code></p> <p>Reverse takes a slice of type T and returns a slice of type T with a reverse order of elements.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    reversed := sliceutils.Reverse(numerals)\n\n    fmt.Print(reversed) // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n}\n</code></pre>"},{"location":"sliceutils/skip/","title":"Skip","text":"<p><code>func Skip[T any](slice []T, n int) []T</code></p> <p>Skip returns the slice with the first n elements removed. If n is greater than or equal to the slice length, returns an empty slice. If n is zero or negative, returns the original slice.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    skip3 := sliceutils.Skip(numbers, 3)\n    fmt.Printf(\"%v\\n\", skip3) // [4 5 6 7 8 9 10]\n\n    skipAll := sliceutils.Skip(numbers, 100)\n    fmt.Printf(\"%v\\n\", skipAll) // []\n}\n</code></pre>"},{"location":"sliceutils/skipLast/","title":"SkipLast","text":"<p><code>func SkipLast[T any](slice []T, n int) []T</code></p> <p>SkipLast returns the slice with the last n elements removed. If n is greater than or equal to the slice length, returns an empty slice. If n is zero or negative, returns the original slice.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    skipLast3 := sliceutils.SkipLast(numbers, 3)\n    fmt.Printf(\"%v\\n\", skipLast3) // [1 2 3 4 5 6 7]\n}\n</code></pre>"},{"location":"sliceutils/skipWhile/","title":"SkipWhile","text":"<p><code>func SkipWhile[T any](slice []T, predicate func(T) bool) []T</code></p> <p>SkipWhile skips elements from the beginning of the slice while the predicate returns true. Returns the remaining elements starting from the first element where the predicate returns false.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Skip while less than 5\n    result := sliceutils.SkipWhile(numbers, func(n int) bool {\n        return n &lt; 5\n    })\n\n    fmt.Printf(\"%v\\n\", result) // [5 6 7 8 9 10]\n}\n</code></pre>"},{"location":"sliceutils/some/","title":"Some","text":"<p><code>func Some[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool</code></p> <p>Some takes a slice of type T and a predicate function, returning true if the predicate returned true for some elements. The function is passed the current element, the current index and the slice itself as function arguments.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    friends := []string{\"John\", \"Bob\", \"Mendy\", \"Suzy\", \"John\"}\n\n    result := sliceutils.Some(friends, func(value string, index int, slice []string) bool {\n        return value == \"Mandy\"\n    })\n\n    fmt.Print(result) // true\n}\n</code></pre>"},{"location":"sliceutils/sum/","title":"Sum","text":"<p><code>func Sum[T numbers](slice []T) (result T)</code></p> <p>Sum takes a slice of numbers T, which can be any of the number types, and returns a sum of their values.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    result := sliceutils.Sum(numerals)\n\n    fmt.Print(result) // 45\n}\n</code></pre>"},{"location":"sliceutils/tail/","title":"Tail","text":"<p><code>func Tail[T any](slice []T) []T</code></p> <p>Tail returns all elements of the slice except the first. Returns an empty slice if the slice has 0 or 1 elements.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    rest := sliceutils.Tail(numbers)\n    fmt.Printf(\"%v\\n\", rest) // [2 3 4 5]\n\n    single := []int{1}\n    emptyTail := sliceutils.Tail(single)\n    fmt.Printf(\"%v\\n\", emptyTail) // []\n}\n</code></pre>"},{"location":"sliceutils/take/","title":"Take","text":"<p><code>func Take[T any](slice []T, n int) []T</code></p> <p>Take returns the first n elements from the slice. If n is greater than the slice length, returns the entire slice. If n is zero or negative, returns an empty slice.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    first3 := sliceutils.Take(numbers, 3)\n    fmt.Printf(\"%v\\n\", first3) // [1 2 3]\n\n    tooMany := sliceutils.Take(numbers, 100)\n    fmt.Printf(\"%v\\n\", tooMany) // [1 2 3 4 5 6 7 8 9 10]\n}\n</code></pre>"},{"location":"sliceutils/takeLast/","title":"TakeLast","text":"<p><code>func TakeLast[T any](slice []T, n int) []T</code></p> <p>TakeLast returns the last n elements from the slice. If n is greater than the slice length, returns the entire slice. If n is zero or negative, returns an empty slice.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    last3 := sliceutils.TakeLast(numbers, 3)\n    fmt.Printf(\"%v\\n\", last3) // [8 9 10]\n}\n</code></pre>"},{"location":"sliceutils/takeWhile/","title":"TakeWhile","text":"<p><code>func TakeWhile[T any](slice []T, predicate func(T) bool) []T</code></p> <p>TakeWhile returns elements from the beginning of the slice while the predicate returns true. Stops at the first element where the predicate returns false.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Take while less than 5\n    result := sliceutils.TakeWhile(numbers, func(n int) bool {\n        return n &lt; 5\n    })\n\n    fmt.Printf(\"%v\\n\", result) // [1 2 3 4]\n}\n</code></pre>"},{"location":"sliceutils/union/","title":"Union","text":"<p><code>func Union[T comparable](slices ...[]T) []T</code></p> <p>Union takes a variadic number of slices of type T and returns a slice of type T containing the unique elements in the different slices.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    first, second := []int{1, 2, 3}, []int{1, 7, 3}\n\n    result := sliceutils.Union(first, second)\n\n    fmt.Print(result) // [1, 2, 3, 7]\n}\n</code></pre>"},{"location":"sliceutils/unique/","title":"Unique","text":"<p><code>func Unique[T comparable](slice []T) []T</code></p> <p>Unique takes a slice of type T and returns a slice of type T containing all unique elements.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numerals := []int{0, 1, 2, 3, 3, 1}\n\n    result := sliceutils.Unique(numerals)\n\n    fmt.Print(result) // [0, 1, 2, 3]\n}\n</code></pre>"},{"location":"sliceutils/windows/","title":"Windows","text":"<p><code>func Windows[T any](slice []T, size int) [][]T</code></p> <p>Windows returns a slice of sliding windows of the specified size. Each window is a slice of consecutive elements. If size is greater than the slice length or less than 1, returns an empty slice.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/sliceutils\"\n)\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n\n    // Get all windows of size 3\n    windows := sliceutils.Windows(numbers, 3)\n    fmt.Printf(\"%v\\n\", windows)\n    // [[1 2 3] [2 3 4] [3 4 5]]\n\n    // Useful for calculating rolling averages, moving statistics, etc.\n}\n</code></pre>"},{"location":"stringutils/","title":"stringutils","text":"<p>String manipulation and type-safe conversion utilities.</p>"},{"location":"stringutils/#overview","title":"Overview","text":"<p>The <code>stringutils</code> package provides utilities for string manipulation and a powerful type-safe <code>Stringify</code> function that converts any value to a string with configurable options.</p>"},{"location":"stringutils/#functions","title":"Functions","text":"<p>Type Conversion: Stringify (with Options) Case Conversion: Capitalize, ToCamelCase, ToSnakeCase, ToKebabCase Padding: PadLeft, PadRight Manipulation: Reverse, Truncate, RemoveWhitespace, EllipsisMiddle Utilities: Contains, SplitAndTrim, JoinNonEmpty, DefaultIfEmpty</p>"},{"location":"stringutils/#example","title":"Example","text":"<pre><code>import \"github.com/Goldziher/go-utils/stringutils\"\n\n// Type-safe stringify with options\nstr := stringutils.Stringify(42)  // \"42\"\nhex := stringutils.Stringify(42, stringutils.Options{Base: 16})  // \"2a\"\nfloat := stringutils.Stringify(3.14159, stringutils.Options{Precision: 2})  // \"3.14\"\n\n// Stringify complex types\nm := map[string]int{\"a\": 1, \"b\": 2}\nstr := stringutils.Stringify(m)  // \"{a: 1, b: 2}\"\n\n// String manipulation\ncapitalized := stringutils.Capitalize(\"hello world\")  // \"Hello world\"\npadded := stringutils.PadLeft(\"42\", \"0\", 5)  // \"00042\"\ncamel := stringutils.ToCamelCase(\"hello_world\")  // \"helloWorld\"\nsnake := stringutils.ToSnakeCase(\"HelloWorld\")  // \"hello_world\"\nkebab := stringutils.ToKebabCase(\"HelloWorld\")  // \"hello-world\"\n\n// Utilities\ntruncated := stringutils.Truncate(\"very long string\", 10, \"...\")  // \"very long ...\"\ncleaned := stringutils.RemoveWhitespace(\"hello world\")  // \"helloworld\"\nparts := stringutils.SplitAndTrim(\"a, b, c\", \",\")  // []string{\"a\", \"b\", \"c\"}\n</code></pre>"},{"location":"stringutils/#stringify-options","title":"Stringify Options","text":"<pre><code>type Options struct {\n    Base           int    // Number base for integers (2-36), default 10\n    Format         byte   // Float format ('f', 'e', 'E', 'g', 'G'), default 'f'\n    Precision      int    // Float precision, default 2\n    NilFormat      string // Format for nil values, default \"&lt;nil&gt;\"\n    NilMapFormat   string // Format for nil maps, default \"{}\"\n    NilSliceFormat string // Format for nil slices, default \"[]\"\n}\n</code></pre>"},{"location":"stringutils/capitalize/","title":"Capitalize","text":"<p><code>func Capitalize(str string) string</code></p> <p>Capitalize - Capitalizes a string by changing the casing format of the first letter of the string.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    result := stringutils.Capitalize(\"coffee\") // \"Coffee\"\n    fmt.Print(result) // \"Coffee\"\n}\n</code></pre>"},{"location":"stringutils/padLeft/","title":"PadLeft","text":"<p><code>func PadLeft(str string, padWith string, padTo int) string</code></p> <p>PadLeft - Pad a string to a certain length with another string on the left side. If padding string is more than one char, it might be trucated to fit padTo size.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    result := stringutils.PadLeft(\"Azer\", \"_\", 7) // \"___Azer\"\n    fmt.Print(result) // \"___Azer\"\n\n    result = stringutils.PadLeft(\"Azer\", \"_-\", 7) // \"_-_Azer\"\n    fmt.Print(result) // \"_-_Azer\"\n}\n</code></pre>"},{"location":"stringutils/padRight/","title":"PadRight","text":"<p><code>func PadRight(str string, padWith string, padTo int) string</code></p> <p>PadRight - Pad a string to a certain length with another string on the right side. If padding string is more than one char, it might be trucated to fit padTo size.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    result := stringutils.PadRight(\"Azer\", \"_\", 7) // \"Azer___\"\n    fmt.Print(result) // \"Azer___\"\n\n\n    result = stringutils.PadRight(\"Azer\", \"_-\", 7) // \"Azer_-_\"\n    fmt.Print(result) // \"Azer_-_\"\n}\n</code></pre>"},{"location":"stringutils/stringify/","title":"Stringify","text":"<p><code>func Stringify(value any, opts ...Options) string</code></p> <p>Stringify receives an arbitrary value and converts it into a string.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/stringutils\"\n)\n\nfunc main() {\n    value := 1000\n\n    result := stringutils.Stringify(value) // \"1000\"\n\n    fmt.Print(result) // \"1000\"\n}\n</code></pre> <p>Stringify also accepts an options object with the following properties:</p> <ul> <li><code>NilFormat</code>: the string format for nil values, defaults to \"\". <li><code>NilMapFormat</code>: the string format for nil map objects, defaults to \"{}\".</li> <li><code>NilSliceFormat</code>: the string format for nil slice objects, defaults to \"[]\".</li> <li><code>Base</code>: a number between 2-36 ad the base when converting ints and uints to strings, defaults to Base 10.</li> <li><code>Precision</code>: number of digits to include when converting floats and complex numbers to strings, defaults to 2.</li> <li><code>Format</code>: the number notation format, using the stlib <code>FTOA</code> functionalities, defaults to 'f':</li> <li>'b' (-ddddp\u00b1ddd, a binary exponent),</li> <li>'e' (-d.dddde\u00b1dd, a decimal exponent),</li> <li>'E' (-d.ddddE\u00b1dd, a decimal exponent),</li> <li>'f' (-ddd.dddd, no exponent),</li> <li>'g' ('e' for large exponents, 'f' otherwise),</li> <li>'G' ('E' for large exponents, 'f' otherwise),</li> <li>'x' (-0xd.ddddp\u00b1ddd, a hexadecimal fraction and binary exponent), or</li> <li>'X' (-0Xd.ddddP\u00b1ddd, a hexadecimal fraction and binary exponent).</li>"},{"location":"structutils/","title":"structutils","text":"<p>Reflection-based struct utilities with struct tag support.</p>"},{"location":"structutils/#overview","title":"Overview","text":"<p>The <code>structutils</code> package provides utilities for working with structs through reflection, including conversion to maps, iteration over fields, and struct tag-aware operations.</p>"},{"location":"structutils/#functions","title":"Functions","text":"<p>Conversion: ToMap Iteration: ForEach Inspection: Fields, Values, FieldNames, HasField, GetField</p>"},{"location":"structutils/#example","title":"Example","text":"<pre><code>import \"github.com/Goldziher/go-utils/structutils\"\n\ntype Config struct {\n    Host     string `json:\"host\" yaml:\"host\"`\n    Port     int    `json:\"port\" yaml:\"port\"`\n    Database string `json:\"database\" yaml:\"database\"`\n    Password string `json:\"-\"`  // Omit from JSON\n}\n\ncfg := Config{\n    Host:     \"localhost\",\n    Port:     5432,\n    Database: \"mydb\",\n    Password: \"secret\",\n}\n\n// Convert to map (respects struct tags)\njsonMap := structutils.ToMap(cfg, \"json\")\n// Result: map[string]any{\n//     \"host\": \"localhost\",\n//     \"port\": 5432,\n//     \"database\": \"mydb\",\n//     // Password omitted due to json:\"-\"\n// }\n\nyamlMap := structutils.ToMap(cfg, \"yaml\")\n// Result: map[string]any{\n//     \"host\": \"localhost\",\n//     \"port\": 5432,\n//     \"database\": \"mydb\",\n//     \"Password\": \"secret\",  // Included as field name\n// }\n\n// Iterate over fields\nstructutils.ForEach(cfg, func(key string, value any, tag reflect.StructTag) {\n    fmt.Printf(\"%s: %v (json:%s)\\n\", key, value, tag.Get(\"json\"))\n})\n\n// Get field names with tag support\nfieldNames := structutils.FieldNames(cfg, \"json\")\n// Result: []string{\"host\", \"port\", \"database\"}\n</code></pre>"},{"location":"structutils/forEach/","title":"ForEach","text":"<p><code>func ForEach[T any](structInstance T, function func(key string, value any, tag reflect.StructTag))</code></p> <p>Takes a struct and calls the passed in function for each of its visible fields, passing to in the field's name, value and tag.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"myValue\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    structutils.ForEach(personInstance, func(key string, value any, tag reflect.StructTag) {\n        fmt.Printf(\"%v - %v - %v\\n\", key, value, tag.Get(\"myTag\"))\n    })\n\n    // FirstName - Moishe\n    // LastName - Zuchmir\n    // Age - 100 - myValue\n}\n</code></pre>"},{"location":"structutils/toMap/","title":"ToMap","text":"<p><code>func ToMap[T any](structInstance T, structTags ...string) map[string]any</code></p> <p>ToMap takes a struct and converts it to into an instance of <code>map[string]any</code>.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"myValue\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    personMap := structutils.ToMap(personInstance)\n\n    fmt.Print(personMap)\n    // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"Age\": 100 }\n}\n</code></pre> <p>You can also pass in struct tags as an optional argument:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"myValue\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    personMap := structutils.ToMap(personInstance, \"myTag\")\n\n    fmt.Print(personMap)\n    // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"myTag\": 100 }\n}\n</code></pre> <p>To omit a value, use the standard <code>\"-\"</code> struct tag value:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/Goldziher/go-utils/structutils\"\n)\n\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int `myTag:\"-\"`\n}\n\nfunc main() {\n    personInstance := Person{\n        FirstName: \"Moishe\",\n        LastName:  \"Zuchmir\",\n        Age:       100,\n    }\n\n    personMap := structutils.ToMap(personInstance, \"myTag\")\n\n    fmt.Print(personMap)\n    // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\" }\n}\n</code></pre>"},{"location":"urlutils/","title":"urlutils","text":"<p>URL parsing and query string builder utilities.</p>"},{"location":"urlutils/#overview","title":"Overview","text":"<p>The <code>urlutils</code> package provides utilities for working with URLs and building query strings from maps and structs with struct tag support.</p>"},{"location":"urlutils/#functions","title":"Functions","text":"<p>Query Builders: QueryStringifyMap, QueryStringifyStruct URL Parsing: Parse, MustParse URL Inspection: IsAbsolute, GetDomain, GetScheme, GetPath</p>"},{"location":"urlutils/#example","title":"Example","text":"<pre><code>import \"github.com/Goldziher/go-utils/urlutils\"\n\n// Build query string from map\nparams := map[string]any{\n    \"search\": \"golang\",\n    \"page\":   1,\n    \"tags\":   []string{\"generics\", \"utils\"},\n    \"active\": true,\n}\nquery := urlutils.QueryStringifyMap(params)\n// Result: \"active=true&amp;page=1&amp;search=golang&amp;tags=generics&amp;tags=utils\"\n\n// Build query string from struct with tags\ntype SearchQuery struct {\n    Query    string   `qs:\"q\"`\n    Page     int      `qs:\"page\"`\n    PageSize int      `qs:\"page_size\"`\n    Tags     []string `qs:\"tag\"`\n    Active   bool     `qs:\"active\"`\n}\n\nq := SearchQuery{\n    Query:    \"golang\",\n    Page:     1,\n    PageSize: 20,\n    Tags:     []string{\"generics\", \"utils\"},\n    Active:   true,\n}\nquery := urlutils.QueryStringifyStruct(q, \"qs\")\n// Result: \"active=true&amp;page=1&amp;page_size=20&amp;q=golang&amp;tag=generics&amp;tag=utils\"\n\n// URL parsing and inspection\nu, err := urlutils.Parse(\"https://example.com:8080/path?key=value\")\nif err == nil {\n    domain := urlutils.GetDomain(\"https://example.com:8080/path\")  // \"example.com:8080\"\n    scheme := urlutils.GetScheme(\"https://example.com/path\")       // \"https\"\n    path := urlutils.GetPath(\"https://example.com/path/to/page\")   // \"/path/to/page\"\n    isAbs := urlutils.IsAbsolute(\"https://example.com\")            // true\n}\n\n// Panic on parse error (use when URL is known to be valid)\nu := urlutils.MustParse(\"https://example.com/path\")\n</code></pre>"},{"location":"urlutils/queryStringifyMap/","title":"QueryStringifyMap","text":"<p><code>func QueryStringifyMap[K comparable, V any](values map[K]V) string</code></p> <p>Creates a query string from a given map instance.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := map[string]any{\n        \"user\":    \"moishe\",\n        \"active\":  true,\n        \"age\":     100,\n        \"friends\": []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyMap(values)\n\n    fmt.Print(result) // \"active=true&amp;age=100&amp;friends=1&amp;friends=2&amp;friends=3&amp;friends=4&amp;friends=5&amp;friends=6&amp;user=moishe\"\n}\n</code></pre>"},{"location":"urlutils/queryStringifyStruct/","title":"QueryStringifyStruct","text":"<p><code>func QueryStringifyStruct[T any](values T, structTags ...string) string</code></p> <p>Creates a query string from a given struct instance. Takes struct tag names as optional parameters.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := struct {\n        User    string\n        Active  bool\n        Age     int `qs:\"age\"`\n        Friends []int\n    }{\n        User:    \"moishe\",\n        Active:  true,\n        Age:     100,\n        Friends: []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyStruct(values, \"qs\")\n\n    fmt.Print(result) // \"Active=true&amp;Friends=1&amp;Friends=2&amp;Friends=3&amp;Friends=4&amp;Friends=5&amp;Friends=6&amp;User=moishe&amp;age=100\"\n}\n</code></pre> <p>You can pass as many struct tags as you deem necessary, for example the following will also work:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := struct {\n        User    string\n        Active  bool `json:\"active\"`\n        Age     int `qs:\"age\"`\n        Friends []int\n    }{\n        User:    \"moishe\",\n        Active:  true,\n        Age:     100,\n        Friends: []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyStruct(values, \"json\", \"qs\")\n\n    fmt.Print(result) // \"Friends=1&amp;Friends=2&amp;Friends=3&amp;Friends=4&amp;Friends=5&amp;Friends=6&amp;User=moishe&amp;active=true&amp;age=100\"\n}\n</code></pre> <p>If you want to ignore a field, simply use the conventional tag value of <code>\"-\"</code>:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/Goldziher/go-utils/urlutils\"\n)\n\nfunc main() {\n    values := struct {\n        User    string\n        Active  bool\n        Age     int `qs:\"-\"`\n        Friends []int\n    }{\n        User:    \"moishe\",\n        Active:  true,\n        Age:     100,\n        Friends: []int{1, 2, 3, 4, 5, 6},\n    }\n\n    result := urlutils.QueryStringifyStruct(values, \"qs\")\n\n    fmt.Print(result) // \"Active=true&amp;Friends=1&amp;Friends=2&amp;Friends=3&amp;Friends=4&amp;Friends=5&amp;Friends=6&amp;User=moishe\"\n}\n</code></pre>"}]}